import {
  require_aria2 as require_aria,
  require_constants,
  require_core,
  require_error,
  require_global_node,
  require_objects,
  require_rand,
  require_require,
  require_runtime,
  require_scroll,
  require_size,
  require_style,
  require_utils,
  require_vue
} from "./chunk-MMJPAREY.js";
import {
  init_reactivity_esm_bundler,
  init_shared_esm_bundler,
  reactivity_esm_bundler_exports,
  shared_esm_bundler_exports
} from "./chunk-PARLYUU7.js";
import {
  __commonJS,
  __toCommonJS
} from "./chunk-S5KM4IGW.js";

// node_modules/element-plus/lib/hooks/use-attrs/index.js
var require_use_attrs = __commonJS({
  "node_modules/element-plus/lib/hooks/use-attrs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vue = require_vue();
    var lodashUnified = require_require();
    require_utils();
    var error = require_error();
    var DEFAULT_EXCLUDE_KEYS = ["class", "style"];
    var LISTENER_PREFIX = /^on[A-Z]/;
    var useAttrs = (params = {}) => {
      const { excludeListeners = false, excludeKeys } = params;
      const allExcludeKeys = vue.computed(() => {
        return ((excludeKeys == null ? void 0 : excludeKeys.value) || []).concat(DEFAULT_EXCLUDE_KEYS);
      });
      const instance = vue.getCurrentInstance();
      if (!instance) {
        error.debugWarn("use-attrs", "getCurrentInstance() returned null. useAttrs() must be called at the top of a setup function");
        return vue.computed(() => ({}));
      }
      return vue.computed(() => {
        var _a;
        return lodashUnified.fromPairs(Object.entries((_a = instance.proxy) == null ? void 0 : _a.$attrs).filter(([key]) => !allExcludeKeys.value.includes(key) && !(excludeListeners && LISTENER_PREFIX.test(key))));
      });
    };
    exports.useAttrs = useAttrs;
  }
});

// node_modules/element-plus/lib/tokens/breadcrumb.js
var require_breadcrumb = __commonJS({
  "node_modules/element-plus/lib/tokens/breadcrumb.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var breadcrumbKey = Symbol("breadcrumbKey");
    exports.breadcrumbKey = breadcrumbKey;
  }
});

// node_modules/element-plus/lib/tokens/button.js
var require_button = __commonJS({
  "node_modules/element-plus/lib/tokens/button.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var buttonGroupContextKey = Symbol("buttonGroupContextKey");
    exports.buttonGroupContextKey = buttonGroupContextKey;
  }
});

// node_modules/element-plus/lib/tokens/carousel.js
var require_carousel = __commonJS({
  "node_modules/element-plus/lib/tokens/carousel.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var carouselContextKey = Symbol("carouselContextKey");
    exports.carouselContextKey = carouselContextKey;
  }
});

// node_modules/element-plus/lib/tokens/collapse.js
var require_collapse = __commonJS({
  "node_modules/element-plus/lib/tokens/collapse.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var collapseContextKey = Symbol("collapseContextKey");
    exports.collapseContextKey = collapseContextKey;
  }
});

// node_modules/element-plus/lib/tokens/config-provider.js
var require_config_provider = __commonJS({
  "node_modules/element-plus/lib/tokens/config-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var configProviderContextKey = Symbol();
    exports.configProviderContextKey = configProviderContextKey;
  }
});

// node_modules/element-plus/lib/tokens/dialog.js
var require_dialog = __commonJS({
  "node_modules/element-plus/lib/tokens/dialog.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var dialogInjectionKey = Symbol("dialogInjectionKey");
    exports.dialogInjectionKey = dialogInjectionKey;
  }
});

// node_modules/element-plus/lib/tokens/form.js
var require_form = __commonJS({
  "node_modules/element-plus/lib/tokens/form.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var formContextKey = Symbol("formContextKey");
    var formItemContextKey = Symbol("formItemContextKey");
    exports.formContextKey = formContextKey;
    exports.formItemContextKey = formItemContextKey;
  }
});

// node_modules/element-plus/lib/tokens/pagination.js
var require_pagination = __commonJS({
  "node_modules/element-plus/lib/tokens/pagination.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var elPaginationKey = Symbol("elPaginationKey");
    exports.elPaginationKey = elPaginationKey;
  }
});

// node_modules/element-plus/lib/tokens/radio.js
var require_radio = __commonJS({
  "node_modules/element-plus/lib/tokens/radio.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var radioGroupKey = Symbol("radioGroupKey");
    exports.radioGroupKey = radioGroupKey;
  }
});

// node_modules/element-plus/lib/tokens/row.js
var require_row = __commonJS({
  "node_modules/element-plus/lib/tokens/row.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var rowContextKey = Symbol("rowContextKey");
    exports.rowContextKey = rowContextKey;
  }
});

// node_modules/element-plus/lib/tokens/scrollbar.js
var require_scrollbar = __commonJS({
  "node_modules/element-plus/lib/tokens/scrollbar.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var scrollbarContextKey = Symbol("scrollbarContextKey");
    exports.scrollbarContextKey = scrollbarContextKey;
  }
});

// node_modules/element-plus/lib/tokens/slider.js
var require_slider = __commonJS({
  "node_modules/element-plus/lib/tokens/slider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var sliderContextKey = Symbol("sliderContextKey");
    exports.sliderContextKey = sliderContextKey;
  }
});

// node_modules/element-plus/lib/tokens/tabs.js
var require_tabs = __commonJS({
  "node_modules/element-plus/lib/tokens/tabs.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tabsRootContextKey = Symbol("tabsRootContextKey");
    exports.tabsRootContextKey = tabsRootContextKey;
  }
});

// node_modules/element-plus/lib/tokens/upload.js
var require_upload = __commonJS({
  "node_modules/element-plus/lib/tokens/upload.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var uploadContextKey = Symbol("uploadContextKey");
    exports.uploadContextKey = uploadContextKey;
  }
});

// node_modules/element-plus/lib/tokens/experimental-features.js
var require_experimental_features = __commonJS({
  "node_modules/element-plus/lib/tokens/experimental-features.js"() {
    "use strict";
  }
});

// node_modules/element-plus/lib/tokens/popper.js
var require_popper = __commonJS({
  "node_modules/element-plus/lib/tokens/popper.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var POPPER_INJECTION_KEY = Symbol("popper");
    var POPPER_CONTENT_INJECTION_KEY = Symbol("popperContent");
    exports.POPPER_CONTENT_INJECTION_KEY = POPPER_CONTENT_INJECTION_KEY;
    exports.POPPER_INJECTION_KEY = POPPER_INJECTION_KEY;
  }
});

// node_modules/element-plus/lib/tokens/tooltip-v2.js
var require_tooltip_v2 = __commonJS({
  "node_modules/element-plus/lib/tokens/tooltip-v2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var tooltipV2RootKey = Symbol("tooltipV2");
    var tooltipV2ContentKey = Symbol("tooltipV2Content");
    var TOOLTIP_V2_OPEN = "tooltip_v2.open";
    exports.TOOLTIP_V2_OPEN = TOOLTIP_V2_OPEN;
    exports.tooltipV2ContentKey = tooltipV2ContentKey;
    exports.tooltipV2RootKey = tooltipV2RootKey;
  }
});

// node_modules/element-plus/lib/tokens/date-picker.js
var require_date_picker = __commonJS({
  "node_modules/element-plus/lib/tokens/date-picker.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var ROOT_PICKER_INJECTION_KEY = Symbol();
    exports.ROOT_PICKER_INJECTION_KEY = ROOT_PICKER_INJECTION_KEY;
  }
});

// node_modules/element-plus/lib/tokens/index.js
var require_tokens = __commonJS({
  "node_modules/element-plus/lib/tokens/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var breadcrumb = require_breadcrumb();
    var button = require_button();
    var carousel = require_carousel();
    var collapse = require_collapse();
    var configProvider = require_config_provider();
    var dialog = require_dialog();
    var form = require_form();
    var pagination = require_pagination();
    var radio = require_radio();
    var row = require_row();
    var scrollbar = require_scrollbar();
    var slider = require_slider();
    var tabs = require_tabs();
    var upload = require_upload();
    require_experimental_features();
    var popper = require_popper();
    var tooltipV2 = require_tooltip_v2();
    var datePicker = require_date_picker();
    exports.breadcrumbKey = breadcrumb.breadcrumbKey;
    exports.buttonGroupContextKey = button.buttonGroupContextKey;
    exports.carouselContextKey = carousel.carouselContextKey;
    exports.collapseContextKey = collapse.collapseContextKey;
    exports.configProviderContextKey = configProvider.configProviderContextKey;
    exports.dialogInjectionKey = dialog.dialogInjectionKey;
    exports.formContextKey = form.formContextKey;
    exports.formItemContextKey = form.formItemContextKey;
    exports.elPaginationKey = pagination.elPaginationKey;
    exports.radioGroupKey = radio.radioGroupKey;
    exports.rowContextKey = row.rowContextKey;
    exports.scrollbarContextKey = scrollbar.scrollbarContextKey;
    exports.sliderContextKey = slider.sliderContextKey;
    exports.tabsRootContextKey = tabs.tabsRootContextKey;
    exports.uploadContextKey = upload.uploadContextKey;
    exports.POPPER_CONTENT_INJECTION_KEY = popper.POPPER_CONTENT_INJECTION_KEY;
    exports.POPPER_INJECTION_KEY = popper.POPPER_INJECTION_KEY;
    exports.TOOLTIP_V2_OPEN = tooltipV2.TOOLTIP_V2_OPEN;
    exports.tooltipV2ContentKey = tooltipV2.tooltipV2ContentKey;
    exports.tooltipV2RootKey = tooltipV2.tooltipV2RootKey;
    exports.ROOT_PICKER_INJECTION_KEY = datePicker.ROOT_PICKER_INJECTION_KEY;
  }
});

// node_modules/element-plus/lib/hooks/use-prop/index.js
var require_use_prop = __commonJS({
  "node_modules/element-plus/lib/hooks/use-prop/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vue = require_vue();
    var useProp = (name) => {
      const vm = vue.getCurrentInstance();
      return vue.computed(() => {
        var _a, _b;
        return (_b = ((_a = vm.proxy) == null ? void 0 : _a.$props)[name]) != null ? _b : void 0;
      });
    };
    exports.useProp = useProp;
  }
});

// node_modules/element-plus/lib/hooks/use-global-config/index.js
var require_use_global_config = __commonJS({
  "node_modules/element-plus/lib/hooks/use-global-config/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vue = require_vue();
    require_tokens();
    require_utils();
    var configProvider = require_config_provider();
    var error = require_error();
    var objects = require_objects();
    var globalConfig = vue.ref();
    function useGlobalConfig(key, defaultValue = void 0) {
      const config = vue.getCurrentInstance() ? vue.inject(configProvider.configProviderContextKey, globalConfig) : globalConfig;
      if (key) {
        return vue.computed(() => {
          var _a, _b;
          return (_b = (_a = config.value) == null ? void 0 : _a[key]) != null ? _b : defaultValue;
        });
      } else {
        return config;
      }
    }
    var provideGlobalConfig = (config, app, global = false) => {
      var _a;
      const inSetup = !!vue.getCurrentInstance();
      const oldConfig = inSetup ? useGlobalConfig() : void 0;
      const provideFn = (_a = app == null ? void 0 : app.provide) != null ? _a : inSetup ? vue.provide : void 0;
      if (!provideFn) {
        error.debugWarn("provideGlobalConfig", "provideGlobalConfig() can only be used inside setup().");
        return;
      }
      const context = vue.computed(() => {
        const cfg = vue.unref(config);
        if (!(oldConfig == null ? void 0 : oldConfig.value))
          return cfg;
        return mergeConfig(oldConfig.value, cfg);
      });
      provideFn(configProvider.configProviderContextKey, context);
      if (global || !globalConfig.value) {
        globalConfig.value = context.value;
      }
      return context;
    };
    var mergeConfig = (a, b) => {
      var _a;
      const keys = [.../* @__PURE__ */ new Set([...objects.keysOf(a), ...objects.keysOf(b)])];
      const obj = {};
      for (const key of keys) {
        obj[key] = (_a = b[key]) != null ? _a : a[key];
      }
      return obj;
    };
    exports.provideGlobalConfig = provideGlobalConfig;
    exports.useGlobalConfig = useGlobalConfig;
  }
});

// node_modules/element-plus/lib/hooks/use-common-props/index.js
var require_use_common_props = __commonJS({
  "node_modules/element-plus/lib/hooks/use-common-props/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vue = require_vue();
    require_tokens();
    require_utils();
    require_constants();
    var index = require_use_prop();
    var index$1 = require_use_global_config();
    var runtime = require_runtime();
    var size = require_size();
    var form = require_form();
    var useSizeProp = runtime.buildProp({
      type: String,
      values: size.componentSizes,
      required: false
    });
    var useSize = (fallback, ignore = {}) => {
      const emptyRef = vue.ref(void 0);
      const size2 = ignore.prop ? emptyRef : index.useProp("size");
      const globalConfig = ignore.global ? emptyRef : index$1.useGlobalConfig("size");
      const form$1 = ignore.form ? { size: void 0 } : vue.inject(form.formContextKey, void 0);
      const formItem = ignore.formItem ? { size: void 0 } : vue.inject(form.formItemContextKey, void 0);
      return vue.computed(() => size2.value || vue.unref(fallback) || (formItem == null ? void 0 : formItem.size) || (form$1 == null ? void 0 : form$1.size) || globalConfig.value || "");
    };
    var useDisabled = (fallback) => {
      const disabled = index.useProp("disabled");
      const form$1 = vue.inject(form.formContextKey, void 0);
      return vue.computed(() => disabled.value || vue.unref(fallback) || (form$1 == null ? void 0 : form$1.disabled) || false);
    };
    exports.useDisabled = useDisabled;
    exports.useSize = useSize;
    exports.useSizeProp = useSizeProp;
  }
});

// node_modules/element-plus/lib/hooks/use-deprecated/index.js
var require_use_deprecated = __commonJS({
  "node_modules/element-plus/lib/hooks/use-deprecated/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vue = require_vue();
    require_utils();
    var error = require_error();
    var useDeprecated = ({ from, replacement, scope, version, ref, type = "API" }, condition) => {
      vue.watch(() => vue.unref(condition), (val) => {
        if (val) {
          error.debugWarn(scope, `[${type}] ${from} is about to be deprecated in version ${version}, please use ${replacement} instead.
For more detail, please visit: ${ref}
`);
        }
      }, {
        immediate: true
      });
    };
    exports.useDeprecated = useDeprecated;
  }
});

// node_modules/element-plus/lib/hooks/use-draggable/index.js
var require_use_draggable = __commonJS({
  "node_modules/element-plus/lib/hooks/use-draggable/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vue = require_vue();
    require_utils();
    var style = require_style();
    var useDraggable = (targetRef, dragRef, draggable) => {
      let transform = {
        offsetX: 0,
        offsetY: 0
      };
      const onMousedown = (e) => {
        const downX = e.clientX;
        const downY = e.clientY;
        const { offsetX, offsetY } = transform;
        const targetRect = targetRef.value.getBoundingClientRect();
        const targetLeft = targetRect.left;
        const targetTop = targetRect.top;
        const targetWidth = targetRect.width;
        const targetHeight = targetRect.height;
        const clientWidth = document.documentElement.clientWidth;
        const clientHeight = document.documentElement.clientHeight;
        const minLeft = -targetLeft + offsetX;
        const minTop = -targetTop + offsetY;
        const maxLeft = clientWidth - targetLeft - targetWidth + offsetX;
        const maxTop = clientHeight - targetTop - targetHeight + offsetY;
        const onMousemove = (e2) => {
          const moveX = Math.min(Math.max(offsetX + e2.clientX - downX, minLeft), maxLeft);
          const moveY = Math.min(Math.max(offsetY + e2.clientY - downY, minTop), maxTop);
          transform = {
            offsetX: moveX,
            offsetY: moveY
          };
          targetRef.value.style.transform = `translate(${style.addUnit(moveX)}, ${style.addUnit(moveY)})`;
        };
        const onMouseup = () => {
          document.removeEventListener("mousemove", onMousemove);
          document.removeEventListener("mouseup", onMouseup);
        };
        document.addEventListener("mousemove", onMousemove);
        document.addEventListener("mouseup", onMouseup);
      };
      const onDraggable = () => {
        if (dragRef.value && targetRef.value) {
          dragRef.value.addEventListener("mousedown", onMousedown);
        }
      };
      const offDraggable = () => {
        if (dragRef.value && targetRef.value) {
          dragRef.value.removeEventListener("mousedown", onMousedown);
        }
      };
      vue.onMounted(() => {
        vue.watchEffect(() => {
          if (draggable.value) {
            onDraggable();
          } else {
            offDraggable();
          }
        });
      });
      vue.onBeforeUnmount(() => {
        offDraggable();
      });
    };
    exports.useDraggable = useDraggable;
  }
});

// node_modules/element-plus/lib/hooks/use-focus/index.js
var require_use_focus = __commonJS({
  "node_modules/element-plus/lib/hooks/use-focus/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var useFocus = (el) => {
      return {
        focus: () => {
          var _a, _b;
          (_b = (_a = el.value) == null ? void 0 : _a.focus) == null ? void 0 : _b.call(_a);
        }
      };
    };
    exports.useFocus = useFocus;
  }
});

// node_modules/element-plus/lib/hooks/use-namespace/index.js
var require_use_namespace = __commonJS({
  "node_modules/element-plus/lib/hooks/use-namespace/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index = require_use_global_config();
    var defaultNamespace = "el";
    var statePrefix = "is-";
    var _bem = (namespace, block, blockSuffix, element, modifier) => {
      let cls = `${namespace}-${block}`;
      if (blockSuffix) {
        cls += `-${blockSuffix}`;
      }
      if (element) {
        cls += `__${element}`;
      }
      if (modifier) {
        cls += `--${modifier}`;
      }
      return cls;
    };
    var useNamespace = (block) => {
      const namespace = index.useGlobalConfig("namespace", defaultNamespace);
      const b = (blockSuffix = "") => _bem(namespace.value, block, blockSuffix, "", "");
      const e = (element) => element ? _bem(namespace.value, block, "", element, "") : "";
      const m = (modifier) => modifier ? _bem(namespace.value, block, "", "", modifier) : "";
      const be = (blockSuffix, element) => blockSuffix && element ? _bem(namespace.value, block, blockSuffix, element, "") : "";
      const em = (element, modifier) => element && modifier ? _bem(namespace.value, block, "", element, modifier) : "";
      const bm = (blockSuffix, modifier) => blockSuffix && modifier ? _bem(namespace.value, block, blockSuffix, "", modifier) : "";
      const bem = (blockSuffix, element, modifier) => blockSuffix && element && modifier ? _bem(namespace.value, block, blockSuffix, element, modifier) : "";
      const is = (name, ...args) => {
        const state = args.length >= 1 ? args[0] : true;
        return name && state ? `${statePrefix}${name}` : "";
      };
      const cssVar = (object) => {
        const styles = {};
        for (const key in object) {
          if (object[key]) {
            styles[`--${namespace.value}-${key}`] = object[key];
          }
        }
        return styles;
      };
      const cssVarBlock = (object) => {
        const styles = {};
        for (const key in object) {
          if (object[key]) {
            styles[`--${namespace.value}-${block}-${key}`] = object[key];
          }
        }
        return styles;
      };
      const cssVarName = (name) => `--${namespace.value}-${name}`;
      const cssVarBlockName = (name) => `--${namespace.value}-${block}-${name}`;
      return {
        namespace,
        b,
        e,
        m,
        be,
        em,
        bm,
        bem,
        is,
        cssVar,
        cssVarName,
        cssVarBlock,
        cssVarBlockName
      };
    };
    exports.defaultNamespace = defaultNamespace;
    exports.useNamespace = useNamespace;
  }
});

// node_modules/element-plus/lib/hooks/use-id/index.js
var require_use_id = __commonJS({
  "node_modules/element-plus/lib/hooks/use-id/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vue = require_vue();
    var core = require_core();
    require_utils();
    var index = require_use_global_config();
    var index$1 = require_use_namespace();
    var error = require_error();
    var defaultIdInjection = {
      prefix: Math.floor(Math.random() * 1e4),
      current: 0
    };
    var ID_INJECTION_KEY = Symbol("elIdInjection");
    var useId = (deterministicId) => {
      const idInjection = vue.inject(ID_INJECTION_KEY, defaultIdInjection);
      if (!core.isClient && idInjection === defaultIdInjection) {
        error.debugWarn("IdInjection", `Looks like you are using server rendering, you must provide a id provider to ensure the hydration process to be succeed
usage: app.provide(ID_INJECTION_KEY, {
  prefix: number,
  current: number,
})`);
      }
      const namespace = index.useGlobalConfig("namespace", index$1.defaultNamespace);
      const idRef = vue.computed(() => vue.unref(deterministicId) || `${namespace.value}-id-${idInjection.prefix}-${idInjection.current++}`);
      return idRef;
    };
    exports.ID_INJECTION_KEY = ID_INJECTION_KEY;
    exports.useId = useId;
  }
});

// node_modules/element-plus/lib/hooks/use-form-item/index.js
var require_use_form_item = __commonJS({
  "node_modules/element-plus/lib/hooks/use-form-item/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vue = require_vue();
    require_tokens();
    var index = require_use_id();
    var form = require_form();
    var useFormItem = () => {
      const form$1 = vue.inject(form.formContextKey, void 0);
      const formItem = vue.inject(form.formItemContextKey, void 0);
      return {
        form: form$1,
        formItem
      };
    };
    var useFormItemInputId = (props, {
      formItemContext,
      disableIdGeneration,
      disableIdManagement
    }) => {
      if (!disableIdGeneration) {
        disableIdGeneration = vue.ref(false);
      }
      if (!disableIdManagement) {
        disableIdManagement = vue.ref(false);
      }
      const inputId = vue.ref();
      let idUnwatch = void 0;
      const isLabeledByFormItem = vue.computed(() => {
        var _a;
        return !!(!props.label && formItemContext && formItemContext.inputIds && ((_a = formItemContext.inputIds) == null ? void 0 : _a.length) <= 1);
      });
      vue.onMounted(() => {
        idUnwatch = vue.watch([vue.toRef(props, "id"), disableIdGeneration], ([id, disableIdGeneration2]) => {
          const newId = id != null ? id : !disableIdGeneration2 ? index.useId().value : void 0;
          if (newId !== inputId.value) {
            if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
              inputId.value && formItemContext.removeInputId(inputId.value);
              if (!(disableIdManagement == null ? void 0 : disableIdManagement.value) && !disableIdGeneration2 && newId) {
                formItemContext.addInputId(newId);
              }
            }
            inputId.value = newId;
          }
        }, { immediate: true });
      });
      vue.onUnmounted(() => {
        idUnwatch && idUnwatch();
        if (formItemContext == null ? void 0 : formItemContext.removeInputId) {
          inputId.value && formItemContext.removeInputId(inputId.value);
        }
      });
      return {
        isLabeledByFormItem,
        inputId
      };
    };
    exports.useFormItem = useFormItem;
    exports.useFormItemInputId = useFormItemInputId;
  }
});

// node_modules/element-plus/lib/locale/lang/en.js
var require_en = __commonJS({
  "node_modules/element-plus/lib/locale/lang/en.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var English = {
      name: "en",
      el: {
        colorpicker: {
          confirm: "OK",
          clear: "Clear",
          defaultLabel: "color picker",
          description: "current color is {color}. press enter to select a new color."
        },
        datepicker: {
          now: "Now",
          today: "Today",
          cancel: "Cancel",
          clear: "Clear",
          confirm: "OK",
          dateTablePrompt: "Use the arrow keys and enter to select the day of the month",
          monthTablePrompt: "Use the arrow keys and enter to select the month",
          yearTablePrompt: "Use the arrow keys and enter to select the year",
          selectedDate: "Selected date",
          selectDate: "Select date",
          selectTime: "Select time",
          startDate: "Start Date",
          startTime: "Start Time",
          endDate: "End Date",
          endTime: "End Time",
          prevYear: "Previous Year",
          nextYear: "Next Year",
          prevMonth: "Previous Month",
          nextMonth: "Next Month",
          year: "",
          month1: "January",
          month2: "February",
          month3: "March",
          month4: "April",
          month5: "May",
          month6: "June",
          month7: "July",
          month8: "August",
          month9: "September",
          month10: "October",
          month11: "November",
          month12: "December",
          week: "week",
          weeks: {
            sun: "Sun",
            mon: "Mon",
            tue: "Tue",
            wed: "Wed",
            thu: "Thu",
            fri: "Fri",
            sat: "Sat"
          },
          weeksFull: {
            sun: "Sunday",
            mon: "Monday",
            tue: "Tuesday",
            wed: "Wednesday",
            thu: "Thursday",
            fri: "Friday",
            sat: "Saturday"
          },
          months: {
            jan: "Jan",
            feb: "Feb",
            mar: "Mar",
            apr: "Apr",
            may: "May",
            jun: "Jun",
            jul: "Jul",
            aug: "Aug",
            sep: "Sep",
            oct: "Oct",
            nov: "Nov",
            dec: "Dec"
          }
        },
        inputNumber: {
          decrease: "decrease number",
          increase: "increase number"
        },
        select: {
          loading: "Loading",
          noMatch: "No matching data",
          noData: "No data",
          placeholder: "Select"
        },
        dropdown: {
          toggleDropdown: "Toggle Dropdown"
        },
        cascader: {
          noMatch: "No matching data",
          loading: "Loading",
          placeholder: "Select",
          noData: "No data"
        },
        pagination: {
          goto: "Go to",
          pagesize: "/page",
          total: "Total {total}",
          pageClassifier: "",
          deprecationWarning: "Deprecated usages detected, please refer to the el-pagination documentation for more details"
        },
        dialog: {
          close: "Close this dialog"
        },
        drawer: {
          close: "Close this dialog"
        },
        messagebox: {
          title: "Message",
          confirm: "OK",
          cancel: "Cancel",
          error: "Illegal input",
          close: "Close this dialog"
        },
        upload: {
          deleteTip: "press delete to remove",
          delete: "Delete",
          preview: "Preview",
          continue: "Continue"
        },
        slider: {
          defaultLabel: "slider between {min} and {max}",
          defaultRangeStartLabel: "pick start value",
          defaultRangeEndLabel: "pick end value"
        },
        table: {
          emptyText: "No Data",
          confirmFilter: "Confirm",
          resetFilter: "Reset",
          clearFilter: "All",
          sumText: "Sum"
        },
        tree: {
          emptyText: "No Data"
        },
        transfer: {
          noMatch: "No matching data",
          noData: "No data",
          titles: ["List 1", "List 2"],
          filterPlaceholder: "Enter keyword",
          noCheckedFormat: "{total} items",
          hasCheckedFormat: "{checked}/{total} checked"
        },
        image: {
          error: "FAILED"
        },
        pageHeader: {
          title: "Back"
        },
        popconfirm: {
          confirmButtonText: "Yes",
          cancelButtonText: "No"
        }
      }
    };
    exports["default"] = English;
  }
});

// node_modules/element-plus/lib/hooks/use-locale/index.js
var require_use_locale = __commonJS({
  "node_modules/element-plus/lib/hooks/use-locale/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vue = require_vue();
    var lodashUnified = require_require();
    var en = require_en();
    var index = require_use_global_config();
    var buildTranslator = (locale) => (path, option) => translate(path, option, vue.unref(locale));
    var translate = (path, option, locale) => lodashUnified.get(locale, path, path).replace(/\{(\w+)\}/g, (_, key) => {
      var _a;
      return `${(_a = option == null ? void 0 : option[key]) != null ? _a : `{${key}}`}`;
    });
    var buildLocaleContext = (locale) => {
      const lang = vue.computed(() => vue.unref(locale).name);
      const localeRef = vue.isRef(locale) ? locale : vue.ref(locale);
      return {
        lang,
        locale: localeRef,
        t: buildTranslator(locale)
      };
    };
    var useLocale = () => {
      const locale = index.useGlobalConfig("locale");
      return buildLocaleContext(vue.computed(() => locale.value || en["default"]));
    };
    exports.buildLocaleContext = buildLocaleContext;
    exports.buildTranslator = buildTranslator;
    exports.translate = translate;
    exports.useLocale = useLocale;
  }
});

// node_modules/element-plus/lib/hooks/use-lockscreen/index.js
var require_use_lockscreen = __commonJS({
  "node_modules/element-plus/lib/hooks/use-lockscreen/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vue = require_vue();
    var reactivity = (init_reactivity_esm_bundler(), __toCommonJS(reactivity_esm_bundler_exports));
    var core = require_core();
    require_utils();
    var index = require_use_namespace();
    var error = require_error();
    var style = require_style();
    var scroll = require_scroll();
    var useLockscreen = (trigger) => {
      if (!vue.isRef(trigger)) {
        error.throwError("[useLockscreen]", "You need to pass a ref param to this function");
      }
      const ns = index.useNamespace("popup");
      const hiddenCls = reactivity.computed(() => ns.bm("parent", "hidden"));
      if (!core.isClient || style.hasClass(document.body, hiddenCls.value)) {
        return;
      }
      let scrollBarWidth = 0;
      let withoutHiddenClass = false;
      let bodyWidth = "0";
      const cleanup = () => {
        setTimeout(() => {
          style.removeClass(document.body, hiddenCls.value);
          if (withoutHiddenClass) {
            document.body.style.width = bodyWidth;
          }
        }, 200);
      };
      vue.watch(trigger, (val) => {
        if (!val) {
          cleanup();
          return;
        }
        withoutHiddenClass = !style.hasClass(document.body, hiddenCls.value);
        if (withoutHiddenClass) {
          bodyWidth = document.body.style.width;
        }
        scrollBarWidth = scroll.getScrollBarWidth(ns.namespace.value);
        const bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
        const bodyOverflowY = style.getStyle(document.body, "overflowY");
        if (scrollBarWidth > 0 && (bodyHasOverflow || bodyOverflowY === "scroll") && withoutHiddenClass) {
          document.body.style.width = `calc(100% - ${scrollBarWidth}px)`;
        }
        style.addClass(document.body, hiddenCls.value);
      });
      vue.onScopeDispose(() => cleanup());
    };
    exports.useLockscreen = useLockscreen;
  }
});

// node_modules/element-plus/lib/hooks/use-modal/index.js
var require_use_modal = __commonJS({
  "node_modules/element-plus/lib/hooks/use-modal/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vue = require_vue();
    var core = require_core();
    require_constants();
    var aria = require_aria();
    var modalStack = [];
    var closeModal = (e) => {
      if (modalStack.length === 0)
        return;
      if (e.code === aria.EVENT_CODE.esc) {
        e.stopPropagation();
        const topModal = modalStack[modalStack.length - 1];
        topModal.handleClose();
      }
    };
    var useModal = (instance, visibleRef) => {
      vue.watch(visibleRef, (val) => {
        if (val) {
          modalStack.push(instance);
        } else {
          modalStack.splice(modalStack.indexOf(instance), 1);
        }
      });
    };
    if (core.isClient)
      core.useEventListener(document, "keydown", closeModal);
    exports.useModal = useModal;
  }
});

// node_modules/element-plus/lib/hooks/use-model-toggle/index.js
var require_use_model_toggle = __commonJS({
  "node_modules/element-plus/lib/hooks/use-model-toggle/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vue = require_vue();
    var shared = (init_shared_esm_bundler(), __toCommonJS(shared_esm_bundler_exports));
    var core = require_core();
    require_utils();
    var runtime = require_runtime();
    var _prop = runtime.buildProp({
      type: runtime.definePropType(Boolean),
      default: null
    });
    var _event = runtime.buildProp({
      type: runtime.definePropType(Function)
    });
    var createModelToggleComposable = (name) => {
      const updateEventKey = `update:${name}`;
      const updateEventKeyRaw = `onUpdate:${name}`;
      const useModelToggleEmits2 = [updateEventKey];
      const useModelToggleProps2 = {
        [name]: _prop,
        [updateEventKeyRaw]: _event
      };
      const useModelToggle2 = ({
        indicator,
        toggleReason,
        shouldHideWhenRouteChanges,
        shouldProceed,
        onShow,
        onHide
      }) => {
        const instance = vue.getCurrentInstance();
        const { emit } = instance;
        const props = instance.props;
        const hasUpdateHandler = vue.computed(() => shared.isFunction(props[updateEventKeyRaw]));
        const isModelBindingAbsent = vue.computed(() => props[name] === null);
        const doShow = (event) => {
          if (indicator.value === true) {
            return;
          }
          indicator.value = true;
          if (toggleReason) {
            toggleReason.value = event;
          }
          if (shared.isFunction(onShow)) {
            onShow(event);
          }
        };
        const doHide = (event) => {
          if (indicator.value === false) {
            return;
          }
          indicator.value = false;
          if (toggleReason) {
            toggleReason.value = event;
          }
          if (shared.isFunction(onHide)) {
            onHide(event);
          }
        };
        const show = (event) => {
          if (props.disabled === true || shared.isFunction(shouldProceed) && !shouldProceed())
            return;
          const shouldEmit = hasUpdateHandler.value && core.isClient;
          if (shouldEmit) {
            emit(updateEventKey, true);
          }
          if (isModelBindingAbsent.value || !shouldEmit) {
            doShow(event);
          }
        };
        const hide = (event) => {
          if (props.disabled === true || !core.isClient)
            return;
          const shouldEmit = hasUpdateHandler.value && core.isClient;
          if (shouldEmit) {
            emit(updateEventKey, false);
          }
          if (isModelBindingAbsent.value || !shouldEmit) {
            doHide(event);
          }
        };
        const onChange = (val) => {
          if (!core.isBoolean(val))
            return;
          if (props.disabled && val) {
            if (hasUpdateHandler.value) {
              emit(updateEventKey, false);
            }
          } else if (indicator.value !== val) {
            if (val) {
              doShow();
            } else {
              doHide();
            }
          }
        };
        const toggle = () => {
          if (indicator.value) {
            hide();
          } else {
            show();
          }
        };
        vue.watch(() => props[name], onChange);
        if (shouldHideWhenRouteChanges && instance.appContext.config.globalProperties.$route !== void 0) {
          vue.watch(() => ({
            ...instance.proxy.$route
          }), () => {
            if (shouldHideWhenRouteChanges.value && indicator.value) {
              hide();
            }
          });
        }
        vue.onMounted(() => {
          onChange(props[name]);
        });
        return {
          hide,
          show,
          toggle,
          hasUpdateHandler
        };
      };
      return {
        useModelToggle: useModelToggle2,
        useModelToggleProps: useModelToggleProps2,
        useModelToggleEmits: useModelToggleEmits2
      };
    };
    var { useModelToggle, useModelToggleProps, useModelToggleEmits } = createModelToggleComposable("modelValue");
    exports.createModelToggleComposable = createModelToggleComposable;
    exports.useModelToggle = useModelToggle;
    exports.useModelToggleEmits = useModelToggleEmits;
    exports.useModelToggleProps = useModelToggleProps;
  }
});

// node_modules/element-plus/lib/hooks/use-prevent-global/index.js
var require_use_prevent_global = __commonJS({
  "node_modules/element-plus/lib/hooks/use-prevent-global/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vue = require_vue();
    var core = require_core();
    var usePreventGlobal = (indicator, evt, cb) => {
      const prevent = (e) => {
        if (cb(e))
          e.stopImmediatePropagation();
      };
      let stop = void 0;
      vue.watch(() => indicator.value, (val) => {
        if (val) {
          stop = core.useEventListener(document, evt, prevent, true);
        } else {
          stop == null ? void 0 : stop();
        }
      }, { immediate: true });
    };
    exports.usePreventGlobal = usePreventGlobal;
  }
});

// node_modules/element-plus/lib/hooks/use-restore-active/index.js
var require_use_restore_active = __commonJS({
  "node_modules/element-plus/lib/hooks/use-restore-active/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vue = require_vue();
    var useRestoreActive = (toggle, initialFocus) => {
      let previousActive;
      vue.watch(() => toggle.value, (val) => {
        var _a, _b;
        if (val) {
          previousActive = document.activeElement;
          if (vue.isRef(initialFocus)) {
            (_b = (_a = initialFocus.value).focus) == null ? void 0 : _b.call(_a);
          }
        } else {
          if (false) {
            previousActive.focus.call(previousActive);
          } else {
            previousActive.focus();
          }
        }
      });
    };
    exports.useRestoreActive = useRestoreActive;
  }
});

// node_modules/element-plus/lib/hooks/use-same-target/index.js
var require_use_same_target = __commonJS({
  "node_modules/element-plus/lib/hooks/use-same-target/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var shared = (init_shared_esm_bundler(), __toCommonJS(shared_esm_bundler_exports));
    var useSameTarget = (handleClick) => {
      if (!handleClick) {
        return { onClick: shared.NOOP, onMousedown: shared.NOOP, onMouseup: shared.NOOP };
      }
      let mousedownTarget = false;
      let mouseupTarget = false;
      const onClick = (e) => {
        if (mousedownTarget && mouseupTarget) {
          handleClick(e);
        }
        mousedownTarget = mouseupTarget = false;
      };
      const onMousedown = (e) => {
        mousedownTarget = e.target === e.currentTarget;
      };
      const onMouseup = (e) => {
        mouseupTarget = e.target === e.currentTarget;
      };
      return { onClick, onMousedown, onMouseup };
    };
    exports.useSameTarget = useSameTarget;
  }
});

// node_modules/element-plus/lib/hooks/use-teleport/index.js
var require_use_teleport = __commonJS({
  "node_modules/element-plus/lib/hooks/use-teleport/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vue = require_vue();
    var shared = (init_shared_esm_bundler(), __toCommonJS(shared_esm_bundler_exports));
    var core = require_core();
    require_utils();
    var globalNode = require_global_node();
    var useTeleport = (contentRenderer, appendToBody) => {
      const isTeleportVisible = vue.ref(false);
      if (!core.isClient) {
        return {
          isTeleportVisible,
          showTeleport: shared.NOOP,
          hideTeleport: shared.NOOP,
          renderTeleport: shared.NOOP
        };
      }
      let $el = null;
      const showTeleport = () => {
        isTeleportVisible.value = true;
        if ($el !== null)
          return;
        $el = globalNode.createGlobalNode();
      };
      const hideTeleport = () => {
        isTeleportVisible.value = false;
        if ($el !== null) {
          globalNode.removeGlobalNode($el);
          $el = null;
        }
      };
      const renderTeleport = () => {
        return appendToBody.value !== true ? contentRenderer() : isTeleportVisible.value ? [vue.h(vue.Teleport, { to: $el }, contentRenderer())] : void 0;
      };
      vue.onUnmounted(hideTeleport);
      return {
        isTeleportVisible,
        showTeleport,
        hideTeleport,
        renderTeleport
      };
    };
    exports.useTeleport = useTeleport;
  }
});

// node_modules/element-plus/lib/hooks/use-throttle-render/index.js
var require_use_throttle_render = __commonJS({
  "node_modules/element-plus/lib/hooks/use-throttle-render/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vue = require_vue();
    var useThrottleRender = (loading, throttle = 0) => {
      if (throttle === 0)
        return loading;
      const throttled = vue.ref(false);
      let timeoutHandle = 0;
      const dispatchThrottling = () => {
        if (timeoutHandle) {
          clearTimeout(timeoutHandle);
        }
        timeoutHandle = window.setTimeout(() => {
          throttled.value = loading.value;
        }, throttle);
      };
      vue.onMounted(dispatchThrottling);
      vue.watch(() => loading.value, (val) => {
        if (val) {
          dispatchThrottling();
        } else {
          throttled.value = val;
        }
      });
      return throttled;
    };
    exports.useThrottleRender = useThrottleRender;
  }
});

// node_modules/element-plus/lib/hooks/use-timeout/index.js
var require_use_timeout = __commonJS({
  "node_modules/element-plus/lib/hooks/use-timeout/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var core = require_core();
    function useTimeout() {
      let timeoutHandle;
      const registerTimeout = (fn, delay) => {
        cancelTimeout();
        timeoutHandle = window.setTimeout(fn, delay);
      };
      const cancelTimeout = () => window.clearTimeout(timeoutHandle);
      core.tryOnScopeDispose(() => cancelTimeout());
      return {
        registerTimeout,
        cancelTimeout
      };
    }
    exports.useTimeout = useTimeout;
  }
});

// node_modules/element-plus/lib/hooks/use-transition-fallthrough/index.js
var require_use_transition_fallthrough = __commonJS({
  "node_modules/element-plus/lib/hooks/use-transition-fallthrough/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vue = require_vue();
    var AFTER_APPEAR = "after-appear";
    var AFTER_ENTER = "after-enter";
    var AFTER_LEAVE = "after-leave";
    var APPEAR = "appear";
    var APPEAR_CANCELLED = "appear-cancelled";
    var BEFORE_ENTER = "before-enter";
    var BEFORE_LEAVE = "before-leave";
    var ENTER = "enter";
    var ENTER_CANCELLED = "enter-cancelled";
    var LEAVE = "leave";
    var LEAVE_CANCELLED = "leave-cancelled";
    var useTransitionFallthroughEmits = [
      AFTER_APPEAR,
      AFTER_ENTER,
      AFTER_LEAVE,
      APPEAR,
      APPEAR_CANCELLED,
      BEFORE_ENTER,
      BEFORE_LEAVE,
      ENTER,
      ENTER_CANCELLED,
      LEAVE,
      LEAVE_CANCELLED
    ];
    var useTransitionFallthrough = () => {
      const { emit } = vue.getCurrentInstance();
      return {
        onAfterAppear: () => {
          emit(AFTER_APPEAR);
        },
        onAfterEnter: () => {
          emit(AFTER_ENTER);
        },
        onAfterLeave: () => {
          emit(AFTER_LEAVE);
        },
        onAppearCancelled: () => {
          emit(APPEAR_CANCELLED);
        },
        onBeforeEnter: () => {
          emit(BEFORE_ENTER);
        },
        onBeforeLeave: () => {
          emit(BEFORE_LEAVE);
        },
        onEnter: () => {
          emit(ENTER);
        },
        onEnterCancelled: () => {
          emit(ENTER_CANCELLED);
        },
        onLeave: () => {
          emit(LEAVE);
        },
        onLeaveCancelled: () => {
          emit(LEAVE_CANCELLED);
        }
      };
    };
    exports.useTransitionFallthrough = useTransitionFallthrough;
    exports.useTransitionFallthroughEmits = useTransitionFallthroughEmits;
  }
});

// node_modules/element-plus/lib/hooks/use-escape-keydown/index.js
var require_use_escape_keydown = __commonJS({
  "node_modules/element-plus/lib/hooks/use-escape-keydown/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vue = require_vue();
    var core = require_core();
    require_constants();
    var aria = require_aria();
    var registeredEscapeHandlers = [];
    var cachedHandler = (e) => {
      const event = e;
      if (event.key === aria.EVENT_CODE.esc) {
        registeredEscapeHandlers.forEach((registeredHandler) => registeredHandler(event));
      }
    };
    var useEscapeKeydown = (handler) => {
      vue.onMounted(() => {
        if (registeredEscapeHandlers.length === 0) {
          document.addEventListener("keydown", cachedHandler);
        }
        if (core.isClient)
          registeredEscapeHandlers.push(handler);
      });
      vue.onBeforeUnmount(() => {
        registeredEscapeHandlers = registeredEscapeHandlers.filter((registeredHandler) => registeredHandler !== handler);
        if (registeredEscapeHandlers.length === 0) {
          if (core.isClient)
            document.removeEventListener("keydown", cachedHandler);
        }
      });
    };
    exports.useEscapeKeydown = useEscapeKeydown;
  }
});

// node_modules/element-plus/lib/hooks/use-popper-container/index.js
var require_use_popper_container = __commonJS({
  "node_modules/element-plus/lib/hooks/use-popper-container/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vue = require_vue();
    var core = require_core();
    require_utils();
    var index = require_use_global_config();
    var index$1 = require_use_namespace();
    var rand = require_rand();
    var cachedContainer;
    var namespace = index.useGlobalConfig("namespace", index$1.defaultNamespace);
    var POPPER_CONTAINER_ID = `${namespace.value}-popper-container-${rand.generateId()}`;
    var POPPER_CONTAINER_SELECTOR = `#${POPPER_CONTAINER_ID}`;
    var createContainer = () => {
      const container = document.createElement("div");
      container.id = POPPER_CONTAINER_ID;
      document.body.appendChild(container);
      return container;
    };
    var usePopperContainer = () => {
      vue.onBeforeMount(() => {
        if (!core.isClient)
          return;
        if (!cachedContainer || !document.body.querySelector(POPPER_CONTAINER_SELECTOR)) {
          cachedContainer = createContainer();
        }
      });
    };
    exports.POPPER_CONTAINER_ID = POPPER_CONTAINER_ID;
    exports.POPPER_CONTAINER_SELECTOR = POPPER_CONTAINER_SELECTOR;
    exports.usePopperContainer = usePopperContainer;
  }
});

// node_modules/element-plus/lib/hooks/use-intermediate-render/index.js
var require_use_intermediate_render = __commonJS({
  "node_modules/element-plus/lib/hooks/use-intermediate-render/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vue = require_vue();
    var useDelayedRender = ({
      indicator,
      intermediateIndicator,
      shouldSetIntermediate = () => true,
      beforeShow,
      afterShow,
      afterHide,
      beforeHide
    }) => {
      vue.watch(() => vue.unref(indicator), (val) => {
        if (val) {
          beforeShow == null ? void 0 : beforeShow();
          vue.nextTick(() => {
            if (!vue.unref(indicator))
              return;
            if (shouldSetIntermediate("show")) {
              intermediateIndicator.value = true;
            }
          });
        } else {
          beforeHide == null ? void 0 : beforeHide();
          vue.nextTick(() => {
            if (vue.unref(indicator))
              return;
            if (shouldSetIntermediate("hide")) {
              intermediateIndicator.value = false;
            }
          });
        }
      });
      vue.watch(() => intermediateIndicator.value, (val) => {
        if (val) {
          afterShow == null ? void 0 : afterShow();
        } else {
          afterHide == null ? void 0 : afterHide();
        }
      });
    };
    exports.useDelayedRender = useDelayedRender;
  }
});

// node_modules/element-plus/lib/hooks/use-delayed-toggle/index.js
var require_use_delayed_toggle = __commonJS({
  "node_modules/element-plus/lib/hooks/use-delayed-toggle/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vue = require_vue();
    require_utils();
    var index = require_use_timeout();
    var runtime = require_runtime();
    var useDelayedToggleProps = runtime.buildProps({
      showAfter: {
        type: Number,
        default: 0
      },
      hideAfter: {
        type: Number,
        default: 200
      }
    });
    var useDelayedToggle = ({
      showAfter,
      hideAfter,
      open,
      close
    }) => {
      const { registerTimeout } = index.useTimeout();
      const onOpen = (event) => {
        registerTimeout(() => {
          open(event);
        }, vue.unref(showAfter));
      };
      const onClose = (event) => {
        registerTimeout(() => {
          close(event);
        }, vue.unref(hideAfter));
      };
      return {
        onOpen,
        onClose
      };
    };
    exports.useDelayedToggle = useDelayedToggle;
    exports.useDelayedToggleProps = useDelayedToggleProps;
  }
});

// node_modules/element-plus/lib/hooks/use-forward-ref/index.js
var require_use_forward_ref = __commonJS({
  "node_modules/element-plus/lib/hooks/use-forward-ref/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vue = require_vue();
    var FORWARD_REF_INJECTION_KEY = Symbol("elForwardRef");
    var useForwardRef = (forwardRef) => {
      const setForwardRef = (el) => {
        forwardRef.value = el;
      };
      vue.provide(FORWARD_REF_INJECTION_KEY, {
        setForwardRef
      });
    };
    var useForwardRefDirective = (setForwardRef) => {
      return {
        mounted(el) {
          setForwardRef(el);
        },
        updated(el) {
          setForwardRef(el);
        },
        unmounted() {
          setForwardRef(null);
        }
      };
    };
    exports.FORWARD_REF_INJECTION_KEY = FORWARD_REF_INJECTION_KEY;
    exports.useForwardRef = useForwardRef;
    exports.useForwardRefDirective = useForwardRefDirective;
  }
});

// node_modules/element-plus/lib/hooks/use-z-index/index.js
var require_use_z_index = __commonJS({
  "node_modules/element-plus/lib/hooks/use-z-index/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vue = require_vue();
    var index = require_use_global_config();
    var zIndex = vue.ref(0);
    var useZIndex = () => {
      const initialZIndex = index.useGlobalConfig("zIndex", 2e3);
      const currentZIndex = vue.computed(() => initialZIndex.value + zIndex.value);
      const nextZIndex = () => {
        zIndex.value++;
        return currentZIndex.value;
      };
      return {
        initialZIndex,
        currentZIndex,
        nextZIndex
      };
    };
    exports.useZIndex = useZIndex;
  }
});

// node_modules/@floating-ui/core/dist/floating-ui.core.umd.js
var require_floating_ui_core_umd = __commonJS({
  "node_modules/@floating-ui/core/dist/floating-ui.core.umd.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports) : typeof define === "function" && define.amd ? define(["exports"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.FloatingUICore = {}));
    })(exports, function(exports2) {
      "use strict";
      function getSide(placement) {
        return placement.split("-")[0];
      }
      function getAlignment(placement) {
        return placement.split("-")[1];
      }
      function getMainAxisFromPlacement(placement) {
        return ["top", "bottom"].includes(getSide(placement)) ? "x" : "y";
      }
      function getLengthFromAxis(axis) {
        return axis === "y" ? "height" : "width";
      }
      function computeCoordsFromPlacement(_ref, placement, rtl) {
        let {
          reference,
          floating
        } = _ref;
        const commonX = reference.x + reference.width / 2 - floating.width / 2;
        const commonY = reference.y + reference.height / 2 - floating.height / 2;
        const mainAxis = getMainAxisFromPlacement(placement);
        const length = getLengthFromAxis(mainAxis);
        const commonAlign = reference[length] / 2 - floating[length] / 2;
        const side = getSide(placement);
        const isVertical = mainAxis === "x";
        let coords;
        switch (side) {
          case "top":
            coords = {
              x: commonX,
              y: reference.y - floating.height
            };
            break;
          case "bottom":
            coords = {
              x: commonX,
              y: reference.y + reference.height
            };
            break;
          case "right":
            coords = {
              x: reference.x + reference.width,
              y: commonY
            };
            break;
          case "left":
            coords = {
              x: reference.x - floating.width,
              y: commonY
            };
            break;
          default:
            coords = {
              x: reference.x,
              y: reference.y
            };
        }
        switch (getAlignment(placement)) {
          case "start":
            coords[mainAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
            break;
          case "end":
            coords[mainAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
            break;
        }
        return coords;
      }
      const computePosition = async (reference, floating, config) => {
        const {
          placement = "bottom",
          strategy = "absolute",
          middleware = [],
          platform
        } = config;
        const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(floating));
        {
          if (platform == null) {
            console.error(["Floating UI: `platform` property was not passed to config. If you", "want to use Floating UI on the web, install @floating-ui/dom", "instead of the /core package. Otherwise, you can create your own", "`platform`: https://floating-ui.com/docs/platform"].join(" "));
          }
          if (middleware.filter((_ref) => {
            let {
              name
            } = _ref;
            return name === "autoPlacement" || name === "flip";
          }).length > 1) {
            throw new Error(["Floating UI: duplicate `flip` and/or `autoPlacement`", "middleware detected. This will lead to an infinite loop. Ensure only", "one of either has been passed to the `middleware` array."].join(" "));
          }
        }
        let rects = await platform.getElementRects({
          reference,
          floating,
          strategy
        });
        let {
          x,
          y
        } = computeCoordsFromPlacement(rects, placement, rtl);
        let statefulPlacement = placement;
        let middlewareData = {};
        let resetCount = 0;
        for (let i = 0; i < middleware.length; i++) {
          const {
            name,
            fn
          } = middleware[i];
          const {
            x: nextX,
            y: nextY,
            data,
            reset
          } = await fn({
            x,
            y,
            initialPlacement: placement,
            placement: statefulPlacement,
            strategy,
            middlewareData,
            rects,
            platform,
            elements: {
              reference,
              floating
            }
          });
          x = nextX != null ? nextX : x;
          y = nextY != null ? nextY : y;
          middlewareData = {
            ...middlewareData,
            [name]: {
              ...middlewareData[name],
              ...data
            }
          };
          {
            if (resetCount > 50) {
              console.warn(["Floating UI: The middleware lifecycle appears to be running in an", "infinite loop. This is usually caused by a `reset` continually", "being returned without a break condition."].join(" "));
            }
          }
          if (reset && resetCount <= 50) {
            resetCount++;
            if (typeof reset === "object") {
              if (reset.placement) {
                statefulPlacement = reset.placement;
              }
              if (reset.rects) {
                rects = reset.rects === true ? await platform.getElementRects({
                  reference,
                  floating,
                  strategy
                }) : reset.rects;
              }
              ({
                x,
                y
              } = computeCoordsFromPlacement(rects, statefulPlacement, rtl));
            }
            i = -1;
            continue;
          }
        }
        return {
          x,
          y,
          placement: statefulPlacement,
          strategy,
          middlewareData
        };
      };
      function expandPaddingObject(padding) {
        return {
          top: 0,
          right: 0,
          bottom: 0,
          left: 0,
          ...padding
        };
      }
      function getSideObjectFromPadding(padding) {
        return typeof padding !== "number" ? expandPaddingObject(padding) : {
          top: padding,
          right: padding,
          bottom: padding,
          left: padding
        };
      }
      function rectToClientRect(rect) {
        return {
          ...rect,
          top: rect.y,
          left: rect.x,
          right: rect.x + rect.width,
          bottom: rect.y + rect.height
        };
      }
      async function detectOverflow(middlewareArguments, options) {
        var _await$platform$isEle;
        if (options === void 0) {
          options = {};
        }
        const {
          x,
          y,
          platform,
          rects,
          elements,
          strategy
        } = middlewareArguments;
        const {
          boundary = "clippingAncestors",
          rootBoundary = "viewport",
          elementContext = "floating",
          altBoundary = false,
          padding = 0
        } = options;
        const paddingObject = getSideObjectFromPadding(padding);
        const altContext = elementContext === "floating" ? "reference" : "floating";
        const element = elements[altBoundary ? altContext : elementContext];
        const clippingClientRect = rectToClientRect(await platform.getClippingRect({
          element: ((_await$platform$isEle = await (platform.isElement == null ? void 0 : platform.isElement(element))) != null ? _await$platform$isEle : true) ? element : element.contextElement || await (platform.getDocumentElement == null ? void 0 : platform.getDocumentElement(elements.floating)),
          boundary,
          rootBoundary,
          strategy
        }));
        const elementClientRect = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
          rect: elementContext === "floating" ? {
            ...rects.floating,
            x,
            y
          } : rects.reference,
          offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),
          strategy
        }) : rects[elementContext]);
        return {
          top: clippingClientRect.top - elementClientRect.top + paddingObject.top,
          bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,
          left: clippingClientRect.left - elementClientRect.left + paddingObject.left,
          right: elementClientRect.right - clippingClientRect.right + paddingObject.right
        };
      }
      const min = Math.min;
      const max = Math.max;
      function within(min$1, value, max$1) {
        return max(min$1, min(value, max$1));
      }
      const arrow = (options) => ({
        name: "arrow",
        options,
        async fn(middlewareArguments) {
          const {
            element,
            padding = 0
          } = options != null ? options : {};
          const {
            x,
            y,
            placement,
            rects,
            platform
          } = middlewareArguments;
          if (element == null) {
            {
              console.warn("Floating UI: No `element` was passed to the `arrow` middleware.");
            }
            return {};
          }
          const paddingObject = getSideObjectFromPadding(padding);
          const coords = {
            x,
            y
          };
          const axis = getMainAxisFromPlacement(placement);
          const alignment = getAlignment(placement);
          const length = getLengthFromAxis(axis);
          const arrowDimensions = await platform.getDimensions(element);
          const minProp = axis === "y" ? "top" : "left";
          const maxProp = axis === "y" ? "bottom" : "right";
          const endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
          const startDiff = coords[axis] - rects.reference[axis];
          const arrowOffsetParent = await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(element));
          let clientSize = arrowOffsetParent ? axis === "y" ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;
          if (clientSize === 0) {
            clientSize = rects.floating[length];
          }
          const centerToReference = endDiff / 2 - startDiff / 2;
          const min2 = paddingObject[minProp];
          const max2 = clientSize - arrowDimensions[length] - paddingObject[maxProp];
          const center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
          const offset2 = within(min2, center, max2);
          const alignmentPadding = alignment === "start" ? paddingObject[minProp] : paddingObject[maxProp];
          const shouldAddOffset = alignmentPadding > 0 && center !== offset2 && rects.reference[length] <= rects.floating[length];
          const alignmentOffset = shouldAddOffset ? center < min2 ? min2 - center : max2 - center : 0;
          return {
            [axis]: coords[axis] - alignmentOffset,
            data: {
              [axis]: offset2,
              centerOffset: center - offset2
            }
          };
        }
      });
      const hash$1 = {
        left: "right",
        right: "left",
        bottom: "top",
        top: "bottom"
      };
      function getOppositePlacement(placement) {
        return placement.replace(/left|right|bottom|top/g, (matched) => hash$1[matched]);
      }
      function getAlignmentSides(placement, rects, rtl) {
        if (rtl === void 0) {
          rtl = false;
        }
        const alignment = getAlignment(placement);
        const mainAxis = getMainAxisFromPlacement(placement);
        const length = getLengthFromAxis(mainAxis);
        let mainAlignmentSide = mainAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
        if (rects.reference[length] > rects.floating[length]) {
          mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
        }
        return {
          main: mainAlignmentSide,
          cross: getOppositePlacement(mainAlignmentSide)
        };
      }
      const hash = {
        start: "end",
        end: "start"
      };
      function getOppositeAlignmentPlacement(placement) {
        return placement.replace(/start|end/g, (matched) => hash[matched]);
      }
      const sides = ["top", "right", "bottom", "left"];
      const allPlacements = sides.reduce((acc, side) => acc.concat(side, side + "-start", side + "-end"), []);
      function getPlacementList(alignment, autoAlignment, allowedPlacements) {
        const allowedPlacementsSortedByAlignment = alignment ? [...allowedPlacements.filter((placement) => getAlignment(placement) === alignment), ...allowedPlacements.filter((placement) => getAlignment(placement) !== alignment)] : allowedPlacements.filter((placement) => getSide(placement) === placement);
        return allowedPlacementsSortedByAlignment.filter((placement) => {
          if (alignment) {
            return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
          }
          return true;
        });
      }
      const autoPlacement = function(options) {
        if (options === void 0) {
          options = {};
        }
        return {
          name: "autoPlacement",
          options,
          async fn(middlewareArguments) {
            var _middlewareData$autoP, _middlewareData$autoP2, _middlewareData$autoP3, _middlewareData$autoP4, _placementsSortedByLe;
            const {
              x,
              y,
              rects,
              middlewareData,
              placement,
              platform,
              elements
            } = middlewareArguments;
            const {
              alignment = null,
              allowedPlacements = allPlacements,
              autoAlignment = true,
              ...detectOverflowOptions
            } = options;
            const placements = getPlacementList(alignment, autoAlignment, allowedPlacements);
            const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
            const currentIndex = (_middlewareData$autoP = (_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.index) != null ? _middlewareData$autoP : 0;
            const currentPlacement = placements[currentIndex];
            if (currentPlacement == null) {
              return {};
            }
            const {
              main,
              cross
            } = getAlignmentSides(currentPlacement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));
            if (placement !== currentPlacement) {
              return {
                x,
                y,
                reset: {
                  placement: placements[0]
                }
              };
            }
            const currentOverflows = [overflow[getSide(currentPlacement)], overflow[main], overflow[cross]];
            const allOverflows = [...(_middlewareData$autoP3 = (_middlewareData$autoP4 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP4.overflows) != null ? _middlewareData$autoP3 : [], {
              placement: currentPlacement,
              overflows: currentOverflows
            }];
            const nextPlacement = placements[currentIndex + 1];
            if (nextPlacement) {
              return {
                data: {
                  index: currentIndex + 1,
                  overflows: allOverflows
                },
                reset: {
                  placement: nextPlacement
                }
              };
            }
            const placementsSortedByLeastOverflow = allOverflows.slice().sort((a, b) => a.overflows[0] - b.overflows[0]);
            const placementThatFitsOnAllSides = (_placementsSortedByLe = placementsSortedByLeastOverflow.find((_ref) => {
              let {
                overflows
              } = _ref;
              return overflows.every((overflow2) => overflow2 <= 0);
            })) == null ? void 0 : _placementsSortedByLe.placement;
            const resetPlacement = placementThatFitsOnAllSides != null ? placementThatFitsOnAllSides : placementsSortedByLeastOverflow[0].placement;
            if (resetPlacement !== placement) {
              return {
                data: {
                  index: currentIndex + 1,
                  overflows: allOverflows
                },
                reset: {
                  placement: resetPlacement
                }
              };
            }
            return {};
          }
        };
      };
      function getExpandedPlacements(placement) {
        const oppositePlacement = getOppositePlacement(placement);
        return [getOppositeAlignmentPlacement(placement), oppositePlacement, getOppositeAlignmentPlacement(oppositePlacement)];
      }
      const flip = function(options) {
        if (options === void 0) {
          options = {};
        }
        return {
          name: "flip",
          options,
          async fn(middlewareArguments) {
            var _middlewareData$flip;
            const {
              placement,
              middlewareData,
              rects,
              initialPlacement,
              platform,
              elements
            } = middlewareArguments;
            const {
              mainAxis: checkMainAxis = true,
              crossAxis: checkCrossAxis = true,
              fallbackPlacements: specifiedFallbackPlacements,
              fallbackStrategy = "bestFit",
              flipAlignment = true,
              ...detectOverflowOptions
            } = options;
            const side = getSide(placement);
            const isBasePlacement = side === initialPlacement;
            const fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [getOppositePlacement(initialPlacement)] : getExpandedPlacements(initialPlacement));
            const placements = [initialPlacement, ...fallbackPlacements];
            const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
            const overflows = [];
            let overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
            if (checkMainAxis) {
              overflows.push(overflow[side]);
            }
            if (checkCrossAxis) {
              const {
                main,
                cross
              } = getAlignmentSides(placement, rects, await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)));
              overflows.push(overflow[main], overflow[cross]);
            }
            overflowsData = [...overflowsData, {
              placement,
              overflows
            }];
            if (!overflows.every((side2) => side2 <= 0)) {
              var _middlewareData$flip$, _middlewareData$flip2;
              const nextIndex = ((_middlewareData$flip$ = (_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) != null ? _middlewareData$flip$ : 0) + 1;
              const nextPlacement = placements[nextIndex];
              if (nextPlacement) {
                return {
                  data: {
                    index: nextIndex,
                    overflows: overflowsData
                  },
                  reset: {
                    placement: nextPlacement
                  }
                };
              }
              let resetPlacement = "bottom";
              switch (fallbackStrategy) {
                case "bestFit": {
                  var _overflowsData$map$so;
                  const placement2 = (_overflowsData$map$so = overflowsData.map((d) => [d, d.overflows.filter((overflow2) => overflow2 > 0).reduce((acc, overflow2) => acc + overflow2, 0)]).sort((a, b) => a[1] - b[1])[0]) == null ? void 0 : _overflowsData$map$so[0].placement;
                  if (placement2) {
                    resetPlacement = placement2;
                  }
                  break;
                }
                case "initialPlacement":
                  resetPlacement = initialPlacement;
                  break;
              }
              if (placement !== resetPlacement) {
                return {
                  reset: {
                    placement: resetPlacement
                  }
                };
              }
            }
            return {};
          }
        };
      };
      function getSideOffsets(overflow, rect) {
        return {
          top: overflow.top - rect.height,
          right: overflow.right - rect.width,
          bottom: overflow.bottom - rect.height,
          left: overflow.left - rect.width
        };
      }
      function isAnySideFullyClipped(overflow) {
        return sides.some((side) => overflow[side] >= 0);
      }
      const hide = function(_temp) {
        let {
          strategy = "referenceHidden",
          ...detectOverflowOptions
        } = _temp === void 0 ? {} : _temp;
        return {
          name: "hide",
          async fn(middlewareArguments) {
            const {
              rects
            } = middlewareArguments;
            switch (strategy) {
              case "referenceHidden": {
                const overflow = await detectOverflow(middlewareArguments, {
                  ...detectOverflowOptions,
                  elementContext: "reference"
                });
                const offsets = getSideOffsets(overflow, rects.reference);
                return {
                  data: {
                    referenceHiddenOffsets: offsets,
                    referenceHidden: isAnySideFullyClipped(offsets)
                  }
                };
              }
              case "escaped": {
                const overflow = await detectOverflow(middlewareArguments, {
                  ...detectOverflowOptions,
                  altBoundary: true
                });
                const offsets = getSideOffsets(overflow, rects.floating);
                return {
                  data: {
                    escapedOffsets: offsets,
                    escaped: isAnySideFullyClipped(offsets)
                  }
                };
              }
              default: {
                return {};
              }
            }
          }
        };
      };
      async function convertValueToCoords(middlewareArguments, value) {
        const {
          placement,
          platform,
          elements
        } = middlewareArguments;
        const rtl = await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating));
        const side = getSide(placement);
        const alignment = getAlignment(placement);
        const isVertical = getMainAxisFromPlacement(placement) === "x";
        const mainAxisMulti = ["left", "top"].includes(side) ? -1 : 1;
        const crossAxisMulti = rtl && isVertical ? -1 : 1;
        const rawValue = typeof value === "function" ? value(middlewareArguments) : value;
        let {
          mainAxis,
          crossAxis,
          alignmentAxis
        } = typeof rawValue === "number" ? {
          mainAxis: rawValue,
          crossAxis: 0,
          alignmentAxis: null
        } : {
          mainAxis: 0,
          crossAxis: 0,
          alignmentAxis: null,
          ...rawValue
        };
        if (alignment && typeof alignmentAxis === "number") {
          crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
        }
        return isVertical ? {
          x: crossAxis * crossAxisMulti,
          y: mainAxis * mainAxisMulti
        } : {
          x: mainAxis * mainAxisMulti,
          y: crossAxis * crossAxisMulti
        };
      }
      const offset = function(value) {
        if (value === void 0) {
          value = 0;
        }
        return {
          name: "offset",
          options: value,
          async fn(middlewareArguments) {
            const {
              x,
              y
            } = middlewareArguments;
            const diffCoords = await convertValueToCoords(middlewareArguments, value);
            return {
              x: x + diffCoords.x,
              y: y + diffCoords.y,
              data: diffCoords
            };
          }
        };
      };
      function getCrossAxis(axis) {
        return axis === "x" ? "y" : "x";
      }
      const shift = function(options) {
        if (options === void 0) {
          options = {};
        }
        return {
          name: "shift",
          options,
          async fn(middlewareArguments) {
            const {
              x,
              y,
              placement
            } = middlewareArguments;
            const {
              mainAxis: checkMainAxis = true,
              crossAxis: checkCrossAxis = false,
              limiter = {
                fn: (_ref) => {
                  let {
                    x: x2,
                    y: y2
                  } = _ref;
                  return {
                    x: x2,
                    y: y2
                  };
                }
              },
              ...detectOverflowOptions
            } = options;
            const coords = {
              x,
              y
            };
            const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
            const mainAxis = getMainAxisFromPlacement(getSide(placement));
            const crossAxis = getCrossAxis(mainAxis);
            let mainAxisCoord = coords[mainAxis];
            let crossAxisCoord = coords[crossAxis];
            if (checkMainAxis) {
              const minSide = mainAxis === "y" ? "top" : "left";
              const maxSide = mainAxis === "y" ? "bottom" : "right";
              const min2 = mainAxisCoord + overflow[minSide];
              const max2 = mainAxisCoord - overflow[maxSide];
              mainAxisCoord = within(min2, mainAxisCoord, max2);
            }
            if (checkCrossAxis) {
              const minSide = crossAxis === "y" ? "top" : "left";
              const maxSide = crossAxis === "y" ? "bottom" : "right";
              const min2 = crossAxisCoord + overflow[minSide];
              const max2 = crossAxisCoord - overflow[maxSide];
              crossAxisCoord = within(min2, crossAxisCoord, max2);
            }
            const limitedCoords = limiter.fn({
              ...middlewareArguments,
              [mainAxis]: mainAxisCoord,
              [crossAxis]: crossAxisCoord
            });
            return {
              ...limitedCoords,
              data: {
                x: limitedCoords.x - x,
                y: limitedCoords.y - y
              }
            };
          }
        };
      };
      const limitShift = function(options) {
        if (options === void 0) {
          options = {};
        }
        return {
          options,
          fn(middlewareArguments) {
            const {
              x,
              y,
              placement,
              rects,
              middlewareData
            } = middlewareArguments;
            const {
              offset: offset2 = 0,
              mainAxis: checkMainAxis = true,
              crossAxis: checkCrossAxis = true
            } = options;
            const coords = {
              x,
              y
            };
            const mainAxis = getMainAxisFromPlacement(placement);
            const crossAxis = getCrossAxis(mainAxis);
            let mainAxisCoord = coords[mainAxis];
            let crossAxisCoord = coords[crossAxis];
            const rawOffset = typeof offset2 === "function" ? offset2(middlewareArguments) : offset2;
            const computedOffset = typeof rawOffset === "number" ? {
              mainAxis: rawOffset,
              crossAxis: 0
            } : {
              mainAxis: 0,
              crossAxis: 0,
              ...rawOffset
            };
            if (checkMainAxis) {
              const len = mainAxis === "y" ? "height" : "width";
              const limitMin = rects.reference[mainAxis] - rects.floating[len] + computedOffset.mainAxis;
              const limitMax = rects.reference[mainAxis] + rects.reference[len] - computedOffset.mainAxis;
              if (mainAxisCoord < limitMin) {
                mainAxisCoord = limitMin;
              } else if (mainAxisCoord > limitMax) {
                mainAxisCoord = limitMax;
              }
            }
            if (checkCrossAxis) {
              var _middlewareData$offse, _middlewareData$offse2, _middlewareData$offse3, _middlewareData$offse4;
              const len = mainAxis === "y" ? "width" : "height";
              const isOriginSide = ["top", "left"].includes(getSide(placement));
              const limitMin = rects.reference[crossAxis] - rects.floating[len] + (isOriginSide ? (_middlewareData$offse = (_middlewareData$offse2 = middlewareData.offset) == null ? void 0 : _middlewareData$offse2[crossAxis]) != null ? _middlewareData$offse : 0 : 0) + (isOriginSide ? 0 : computedOffset.crossAxis);
              const limitMax = rects.reference[crossAxis] + rects.reference[len] + (isOriginSide ? 0 : (_middlewareData$offse3 = (_middlewareData$offse4 = middlewareData.offset) == null ? void 0 : _middlewareData$offse4[crossAxis]) != null ? _middlewareData$offse3 : 0) - (isOriginSide ? computedOffset.crossAxis : 0);
              if (crossAxisCoord < limitMin) {
                crossAxisCoord = limitMin;
              } else if (crossAxisCoord > limitMax) {
                crossAxisCoord = limitMax;
              }
            }
            return {
              [mainAxis]: mainAxisCoord,
              [crossAxis]: crossAxisCoord
            };
          }
        };
      };
      const size = function(options) {
        if (options === void 0) {
          options = {};
        }
        return {
          name: "size",
          options,
          async fn(middlewareArguments) {
            const {
              placement,
              rects,
              platform,
              elements
            } = middlewareArguments;
            const {
              apply = () => {
              },
              ...detectOverflowOptions
            } = options;
            const overflow = await detectOverflow(middlewareArguments, detectOverflowOptions);
            const side = getSide(placement);
            const alignment = getAlignment(placement);
            let heightSide;
            let widthSide;
            if (side === "top" || side === "bottom") {
              heightSide = side;
              widthSide = alignment === (await (platform.isRTL == null ? void 0 : platform.isRTL(elements.floating)) ? "start" : "end") ? "left" : "right";
            } else {
              widthSide = side;
              heightSide = alignment === "end" ? "top" : "bottom";
            }
            const xMin = max(overflow.left, 0);
            const xMax = max(overflow.right, 0);
            const yMin = max(overflow.top, 0);
            const yMax = max(overflow.bottom, 0);
            const dimensions = {
              availableHeight: rects.floating.height - (["left", "right"].includes(placement) ? 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom)) : overflow[heightSide]),
              availableWidth: rects.floating.width - (["top", "bottom"].includes(placement) ? 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right)) : overflow[widthSide])
            };
            await apply({
              ...middlewareArguments,
              ...dimensions
            });
            const nextDimensions = await platform.getDimensions(elements.floating);
            if (rects.floating.width !== nextDimensions.width || rects.floating.height !== nextDimensions.height) {
              return {
                reset: {
                  rects: true
                }
              };
            }
            return {};
          }
        };
      };
      const inline = function(options) {
        if (options === void 0) {
          options = {};
        }
        return {
          name: "inline",
          options,
          async fn(middlewareArguments) {
            var _await$platform$getCl;
            const {
              placement,
              elements,
              rects,
              platform,
              strategy
            } = middlewareArguments;
            const {
              padding = 2,
              x,
              y
            } = options;
            const fallback = rectToClientRect(platform.convertOffsetParentRelativeRectToViewportRelativeRect ? await platform.convertOffsetParentRelativeRectToViewportRelativeRect({
              rect: rects.reference,
              offsetParent: await (platform.getOffsetParent == null ? void 0 : platform.getOffsetParent(elements.floating)),
              strategy
            }) : rects.reference);
            const clientRects = (_await$platform$getCl = await (platform.getClientRects == null ? void 0 : platform.getClientRects(elements.reference))) != null ? _await$platform$getCl : [];
            const paddingObject = getSideObjectFromPadding(padding);
            function getBoundingClientRect() {
              if (clientRects.length === 2 && clientRects[0].left > clientRects[1].right && x != null && y != null) {
                var _clientRects$find;
                return (_clientRects$find = clientRects.find((rect) => x > rect.left - paddingObject.left && x < rect.right + paddingObject.right && y > rect.top - paddingObject.top && y < rect.bottom + paddingObject.bottom)) != null ? _clientRects$find : fallback;
              }
              if (clientRects.length >= 2) {
                if (getMainAxisFromPlacement(placement) === "x") {
                  const firstRect = clientRects[0];
                  const lastRect = clientRects[clientRects.length - 1];
                  const isTop = getSide(placement) === "top";
                  const top2 = firstRect.top;
                  const bottom2 = lastRect.bottom;
                  const left2 = isTop ? firstRect.left : lastRect.left;
                  const right2 = isTop ? firstRect.right : lastRect.right;
                  const width2 = right2 - left2;
                  const height2 = bottom2 - top2;
                  return {
                    top: top2,
                    bottom: bottom2,
                    left: left2,
                    right: right2,
                    width: width2,
                    height: height2,
                    x: left2,
                    y: top2
                  };
                }
                const isLeftSide = getSide(placement) === "left";
                const maxRight = max(...clientRects.map((rect) => rect.right));
                const minLeft = min(...clientRects.map((rect) => rect.left));
                const measureRects = clientRects.filter((rect) => isLeftSide ? rect.left === minLeft : rect.right === maxRight);
                const top = measureRects[0].top;
                const bottom = measureRects[measureRects.length - 1].bottom;
                const left = minLeft;
                const right = maxRight;
                const width = right - left;
                const height = bottom - top;
                return {
                  top,
                  bottom,
                  left,
                  right,
                  width,
                  height,
                  x: left,
                  y: top
                };
              }
              return fallback;
            }
            const resetRects = await platform.getElementRects({
              reference: {
                getBoundingClientRect
              },
              floating: elements.floating,
              strategy
            });
            if (rects.reference.x !== resetRects.reference.x || rects.reference.y !== resetRects.reference.y || rects.reference.width !== resetRects.reference.width || rects.reference.height !== resetRects.reference.height) {
              return {
                reset: {
                  rects: resetRects
                }
              };
            }
            return {};
          }
        };
      };
      exports2.arrow = arrow;
      exports2.autoPlacement = autoPlacement;
      exports2.computePosition = computePosition;
      exports2.detectOverflow = detectOverflow;
      exports2.flip = flip;
      exports2.hide = hide;
      exports2.inline = inline;
      exports2.limitShift = limitShift;
      exports2.offset = offset;
      exports2.rectToClientRect = rectToClientRect;
      exports2.shift = shift;
      exports2.size = size;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/@floating-ui/dom/dist/floating-ui.dom.umd.js
var require_floating_ui_dom_umd = __commonJS({
  "node_modules/@floating-ui/dom/dist/floating-ui.dom.umd.js"(exports, module) {
    (function(global, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? factory(exports, require_floating_ui_core_umd()) : typeof define === "function" && define.amd ? define(["exports", "@floating-ui/core"], factory) : (global = typeof globalThis !== "undefined" ? globalThis : global || self, factory(global.FloatingUIDOM = {}, global.FloatingUICore));
    })(exports, function(exports2, core) {
      "use strict";
      function isWindow(value) {
        return value && value.document && value.location && value.alert && value.setInterval;
      }
      function getWindow(node) {
        if (node == null) {
          return window;
        }
        if (!isWindow(node)) {
          const ownerDocument = node.ownerDocument;
          return ownerDocument ? ownerDocument.defaultView || window : window;
        }
        return node;
      }
      function getComputedStyle(element) {
        return getWindow(element).getComputedStyle(element);
      }
      function getNodeName(node) {
        return isWindow(node) ? "" : node ? (node.nodeName || "").toLowerCase() : "";
      }
      function getUAString() {
        const uaData = navigator.userAgentData;
        if (uaData != null && uaData.brands) {
          return uaData.brands.map((item) => item.brand + "/" + item.version).join(" ");
        }
        return navigator.userAgent;
      }
      function isHTMLElement(value) {
        return value instanceof getWindow(value).HTMLElement;
      }
      function isElement(value) {
        return value instanceof getWindow(value).Element;
      }
      function isNode(value) {
        return value instanceof getWindow(value).Node;
      }
      function isShadowRoot(node) {
        if (typeof ShadowRoot === "undefined") {
          return false;
        }
        const OwnElement = getWindow(node).ShadowRoot;
        return node instanceof OwnElement || node instanceof ShadowRoot;
      }
      function isOverflowElement(element) {
        const {
          overflow,
          overflowX,
          overflowY
        } = getComputedStyle(element);
        return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);
      }
      function isTableElement(element) {
        return ["table", "td", "th"].includes(getNodeName(element));
      }
      function isContainingBlock(element) {
        const isFirefox = /firefox/i.test(getUAString());
        const css = getComputedStyle(element);
        return css.transform !== "none" || css.perspective !== "none" || css.contain === "paint" || ["transform", "perspective"].includes(css.willChange) || isFirefox && css.willChange === "filter" || isFirefox && (css.filter ? css.filter !== "none" : false);
      }
      function isLayoutViewport() {
        return !/^((?!chrome|android).)*safari/i.test(getUAString());
      }
      const min = Math.min;
      const max = Math.max;
      const round = Math.round;
      function getBoundingClientRect(element, includeScale, isFixedStrategy) {
        var _win$visualViewport$o, _win$visualViewport, _win$visualViewport$o2, _win$visualViewport2;
        if (includeScale === void 0) {
          includeScale = false;
        }
        if (isFixedStrategy === void 0) {
          isFixedStrategy = false;
        }
        const clientRect = element.getBoundingClientRect();
        let scaleX = 1;
        let scaleY = 1;
        if (includeScale && isHTMLElement(element)) {
          scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;
          scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;
        }
        const win = isElement(element) ? getWindow(element) : window;
        const addVisualOffsets = !isLayoutViewport() && isFixedStrategy;
        const x = (clientRect.left + (addVisualOffsets ? (_win$visualViewport$o = (_win$visualViewport = win.visualViewport) == null ? void 0 : _win$visualViewport.offsetLeft) != null ? _win$visualViewport$o : 0 : 0)) / scaleX;
        const y = (clientRect.top + (addVisualOffsets ? (_win$visualViewport$o2 = (_win$visualViewport2 = win.visualViewport) == null ? void 0 : _win$visualViewport2.offsetTop) != null ? _win$visualViewport$o2 : 0 : 0)) / scaleY;
        const width = clientRect.width / scaleX;
        const height = clientRect.height / scaleY;
        return {
          width,
          height,
          top: y,
          right: x + width,
          bottom: y + height,
          left: x,
          x,
          y
        };
      }
      function getDocumentElement(node) {
        return ((isNode(node) ? node.ownerDocument : node.document) || window.document).documentElement;
      }
      function getNodeScroll(element) {
        if (isElement(element)) {
          return {
            scrollLeft: element.scrollLeft,
            scrollTop: element.scrollTop
          };
        }
        return {
          scrollLeft: element.pageXOffset,
          scrollTop: element.pageYOffset
        };
      }
      function getWindowScrollBarX(element) {
        return getBoundingClientRect(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
      }
      function isScaled(element) {
        const rect = getBoundingClientRect(element);
        return round(rect.width) !== element.offsetWidth || round(rect.height) !== element.offsetHeight;
      }
      function getRectRelativeToOffsetParent(element, offsetParent, strategy) {
        const isOffsetParentAnElement = isHTMLElement(offsetParent);
        const documentElement = getDocumentElement(offsetParent);
        const rect = getBoundingClientRect(
          element,
          isOffsetParentAnElement && isScaled(offsetParent),
          strategy === "fixed"
        );
        let scroll = {
          scrollLeft: 0,
          scrollTop: 0
        };
        const offsets = {
          x: 0,
          y: 0
        };
        if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
          if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
            scroll = getNodeScroll(offsetParent);
          }
          if (isHTMLElement(offsetParent)) {
            const offsetRect = getBoundingClientRect(offsetParent, true);
            offsets.x = offsetRect.x + offsetParent.clientLeft;
            offsets.y = offsetRect.y + offsetParent.clientTop;
          } else if (documentElement) {
            offsets.x = getWindowScrollBarX(documentElement);
          }
        }
        return {
          x: rect.left + scroll.scrollLeft - offsets.x,
          y: rect.top + scroll.scrollTop - offsets.y,
          width: rect.width,
          height: rect.height
        };
      }
      function getParentNode(node) {
        if (getNodeName(node) === "html") {
          return node;
        }
        return node.assignedSlot || node.parentNode || (isShadowRoot(node) ? node.host : null) || getDocumentElement(node);
      }
      function getTrueOffsetParent(element) {
        if (!isHTMLElement(element) || getComputedStyle(element).position === "fixed") {
          return null;
        }
        return element.offsetParent;
      }
      function getContainingBlock(element) {
        let currentNode = getParentNode(element);
        if (isShadowRoot(currentNode)) {
          currentNode = currentNode.host;
        }
        while (isHTMLElement(currentNode) && !["html", "body"].includes(getNodeName(currentNode))) {
          if (isContainingBlock(currentNode)) {
            return currentNode;
          } else {
            const parent = currentNode.parentNode;
            currentNode = isShadowRoot(parent) ? parent.host : parent;
          }
        }
        return null;
      }
      function getOffsetParent(element) {
        const window2 = getWindow(element);
        let offsetParent = getTrueOffsetParent(element);
        while (offsetParent && isTableElement(offsetParent) && getComputedStyle(offsetParent).position === "static") {
          offsetParent = getTrueOffsetParent(offsetParent);
        }
        if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
          return window2;
        }
        return offsetParent || getContainingBlock(element) || window2;
      }
      function getDimensions(element) {
        if (isHTMLElement(element)) {
          return {
            width: element.offsetWidth,
            height: element.offsetHeight
          };
        }
        const rect = getBoundingClientRect(element);
        return {
          width: rect.width,
          height: rect.height
        };
      }
      function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
        let {
          rect,
          offsetParent,
          strategy
        } = _ref;
        const isOffsetParentAnElement = isHTMLElement(offsetParent);
        const documentElement = getDocumentElement(offsetParent);
        if (offsetParent === documentElement) {
          return rect;
        }
        let scroll = {
          scrollLeft: 0,
          scrollTop: 0
        };
        const offsets = {
          x: 0,
          y: 0
        };
        if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
          if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
            scroll = getNodeScroll(offsetParent);
          }
          if (isHTMLElement(offsetParent)) {
            const offsetRect = getBoundingClientRect(offsetParent, true);
            offsets.x = offsetRect.x + offsetParent.clientLeft;
            offsets.y = offsetRect.y + offsetParent.clientTop;
          }
        }
        return {
          ...rect,
          x: rect.x - scroll.scrollLeft + offsets.x,
          y: rect.y - scroll.scrollTop + offsets.y
        };
      }
      function getViewportRect(element, strategy) {
        const win = getWindow(element);
        const html = getDocumentElement(element);
        const visualViewport = win.visualViewport;
        let width = html.clientWidth;
        let height = html.clientHeight;
        let x = 0;
        let y = 0;
        if (visualViewport) {
          width = visualViewport.width;
          height = visualViewport.height;
          const layoutViewport = isLayoutViewport();
          if (layoutViewport || !layoutViewport && strategy === "fixed") {
            x = visualViewport.offsetLeft;
            y = visualViewport.offsetTop;
          }
        }
        return {
          width,
          height,
          x,
          y
        };
      }
      function getDocumentRect(element) {
        var _element$ownerDocumen;
        const html = getDocumentElement(element);
        const scroll = getNodeScroll(element);
        const body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;
        const width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);
        const height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);
        let x = -scroll.scrollLeft + getWindowScrollBarX(element);
        const y = -scroll.scrollTop;
        if (getComputedStyle(body || html).direction === "rtl") {
          x += max(html.clientWidth, body ? body.clientWidth : 0) - width;
        }
        return {
          width,
          height,
          x,
          y
        };
      }
      function getNearestOverflowAncestor(node) {
        const parentNode = getParentNode(node);
        if (["html", "body", "#document"].includes(getNodeName(parentNode))) {
          return node.ownerDocument.body;
        }
        if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
          return parentNode;
        }
        return getNearestOverflowAncestor(parentNode);
      }
      function getOverflowAncestors(node, list) {
        var _node$ownerDocument;
        if (list === void 0) {
          list = [];
        }
        const scrollableAncestor = getNearestOverflowAncestor(node);
        const isBody = scrollableAncestor === ((_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.body);
        const win = getWindow(scrollableAncestor);
        const target = isBody ? [win].concat(win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : []) : scrollableAncestor;
        const updatedList = list.concat(target);
        return isBody ? updatedList : updatedList.concat(getOverflowAncestors(target));
      }
      function contains(parent, child) {
        const rootNode = child.getRootNode == null ? void 0 : child.getRootNode();
        if (parent.contains(child)) {
          return true;
        } else if (rootNode && isShadowRoot(rootNode)) {
          let next = child;
          do {
            if (next && parent === next) {
              return true;
            }
            next = next.parentNode || next.host;
          } while (next);
        }
        return false;
      }
      function getInnerBoundingClientRect(element, strategy) {
        const clientRect = getBoundingClientRect(element, false, strategy === "fixed");
        const top = clientRect.top + element.clientTop;
        const left = clientRect.left + element.clientLeft;
        return {
          top,
          left,
          x: left,
          y: top,
          right: left + element.clientWidth,
          bottom: top + element.clientHeight,
          width: element.clientWidth,
          height: element.clientHeight
        };
      }
      function getClientRectFromClippingAncestor(element, clippingParent, strategy) {
        if (clippingParent === "viewport") {
          return core.rectToClientRect(getViewportRect(element, strategy));
        }
        if (isElement(clippingParent)) {
          return getInnerBoundingClientRect(clippingParent, strategy);
        }
        return core.rectToClientRect(getDocumentRect(getDocumentElement(element)));
      }
      function getClippingAncestors(element) {
        const clippingAncestors = getOverflowAncestors(element);
        const canEscapeClipping = ["absolute", "fixed"].includes(getComputedStyle(element).position);
        const clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;
        if (!isElement(clipperElement)) {
          return [];
        }
        return clippingAncestors.filter((clippingAncestors2) => isElement(clippingAncestors2) && contains(clippingAncestors2, clipperElement) && getNodeName(clippingAncestors2) !== "body");
      }
      function getClippingRect(_ref) {
        let {
          element,
          boundary,
          rootBoundary,
          strategy
        } = _ref;
        const mainClippingAncestors = boundary === "clippingAncestors" ? getClippingAncestors(element) : [].concat(boundary);
        const clippingAncestors = [...mainClippingAncestors, rootBoundary];
        const firstClippingAncestor = clippingAncestors[0];
        const clippingRect = clippingAncestors.reduce((accRect, clippingAncestor) => {
          const rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
          accRect.top = max(rect.top, accRect.top);
          accRect.right = min(rect.right, accRect.right);
          accRect.bottom = min(rect.bottom, accRect.bottom);
          accRect.left = max(rect.left, accRect.left);
          return accRect;
        }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
        return {
          width: clippingRect.right - clippingRect.left,
          height: clippingRect.bottom - clippingRect.top,
          x: clippingRect.left,
          y: clippingRect.top
        };
      }
      const platform = {
        getClippingRect,
        convertOffsetParentRelativeRectToViewportRelativeRect,
        isElement,
        getDimensions,
        getOffsetParent,
        getDocumentElement,
        getElementRects: (_ref) => {
          let {
            reference,
            floating,
            strategy
          } = _ref;
          return {
            reference: getRectRelativeToOffsetParent(reference, getOffsetParent(floating), strategy),
            floating: {
              ...getDimensions(floating),
              x: 0,
              y: 0
            }
          };
        },
        getClientRects: (element) => Array.from(element.getClientRects()),
        isRTL: (element) => getComputedStyle(element).direction === "rtl"
      };
      function autoUpdate(reference, floating, update, options) {
        if (options === void 0) {
          options = {};
        }
        const {
          ancestorScroll: _ancestorScroll = true,
          ancestorResize: _ancestorResize = true,
          elementResize = true,
          animationFrame = false
        } = options;
        const ancestorScroll = _ancestorScroll && !animationFrame;
        const ancestorResize = _ancestorResize && !animationFrame;
        const ancestors = ancestorScroll || ancestorResize ? [...isElement(reference) ? getOverflowAncestors(reference) : [], ...getOverflowAncestors(floating)] : [];
        ancestors.forEach((ancestor) => {
          ancestorScroll && ancestor.addEventListener("scroll", update, {
            passive: true
          });
          ancestorResize && ancestor.addEventListener("resize", update);
        });
        let observer = null;
        if (elementResize) {
          let initialUpdate = true;
          observer = new ResizeObserver(() => {
            if (!initialUpdate) {
              update();
            }
            initialUpdate = false;
          });
          isElement(reference) && !animationFrame && observer.observe(reference);
          observer.observe(floating);
        }
        let frameId;
        let prevRefRect = animationFrame ? getBoundingClientRect(reference) : null;
        if (animationFrame) {
          frameLoop();
        }
        function frameLoop() {
          const nextRefRect = getBoundingClientRect(reference);
          if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
            update();
          }
          prevRefRect = nextRefRect;
          frameId = requestAnimationFrame(frameLoop);
        }
        update();
        return () => {
          var _observer;
          ancestors.forEach((ancestor) => {
            ancestorScroll && ancestor.removeEventListener("scroll", update);
            ancestorResize && ancestor.removeEventListener("resize", update);
          });
          (_observer = observer) == null ? void 0 : _observer.disconnect();
          observer = null;
          if (animationFrame) {
            cancelAnimationFrame(frameId);
          }
        };
      }
      const computePosition = (reference, floating, options) => core.computePosition(reference, floating, {
        platform,
        ...options
      });
      Object.defineProperty(exports2, "arrow", {
        enumerable: true,
        get: function() {
          return core.arrow;
        }
      });
      Object.defineProperty(exports2, "autoPlacement", {
        enumerable: true,
        get: function() {
          return core.autoPlacement;
        }
      });
      Object.defineProperty(exports2, "detectOverflow", {
        enumerable: true,
        get: function() {
          return core.detectOverflow;
        }
      });
      Object.defineProperty(exports2, "flip", {
        enumerable: true,
        get: function() {
          return core.flip;
        }
      });
      Object.defineProperty(exports2, "hide", {
        enumerable: true,
        get: function() {
          return core.hide;
        }
      });
      Object.defineProperty(exports2, "inline", {
        enumerable: true,
        get: function() {
          return core.inline;
        }
      });
      Object.defineProperty(exports2, "limitShift", {
        enumerable: true,
        get: function() {
          return core.limitShift;
        }
      });
      Object.defineProperty(exports2, "offset", {
        enumerable: true,
        get: function() {
          return core.offset;
        }
      });
      Object.defineProperty(exports2, "shift", {
        enumerable: true,
        get: function() {
          return core.shift;
        }
      });
      Object.defineProperty(exports2, "size", {
        enumerable: true,
        get: function() {
          return core.size;
        }
      });
      exports2.autoUpdate = autoUpdate;
      exports2.computePosition = computePosition;
      exports2.getOverflowAncestors = getOverflowAncestors;
      exports2.platform = platform;
      Object.defineProperty(exports2, "__esModule", { value: true });
    });
  }
});

// node_modules/element-plus/lib/hooks/use-floating/index.js
var require_use_floating = __commonJS({
  "node_modules/element-plus/lib/hooks/use-floating/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vue = require_vue();
    var core = require_core();
    var lodashUnified = require_require();
    var dom = require_floating_ui_dom_umd();
    require_utils();
    var runtime = require_runtime();
    var objects = require_objects();
    var useFloatingProps = runtime.buildProps({});
    var unrefReference = (elRef) => {
      if (!core.isClient)
        return;
      if (!elRef)
        return elRef;
      const unrefEl = core.unrefElement(elRef);
      if (unrefEl)
        return unrefEl;
      return vue.isRef(elRef) ? unrefEl : elRef;
    };
    var getPositionDataWithUnit = (record, key) => {
      const value = record == null ? void 0 : record[key];
      return lodashUnified.isNil(value) ? "" : `${value}px`;
    };
    var useFloating = ({
      middleware,
      placement,
      strategy
    }) => {
      const referenceRef = vue.ref();
      const contentRef = vue.ref();
      const x = vue.ref();
      const y = vue.ref();
      const middlewareData = vue.ref({});
      const states = {
        x,
        y,
        placement,
        strategy,
        middlewareData
      };
      const update = async () => {
        if (!core.isClient)
          return;
        const referenceEl = unrefReference(referenceRef);
        const contentEl = core.unrefElement(contentRef);
        if (!referenceEl || !contentEl)
          return;
        const data = await dom.computePosition(referenceEl, contentEl, {
          placement: vue.unref(placement),
          strategy: vue.unref(strategy),
          middleware: vue.unref(middleware)
        });
        objects.keysOf(states).forEach((key) => {
          states[key].value = data[key];
        });
      };
      vue.onMounted(() => {
        vue.watchEffect(() => {
          update();
        });
      });
      return {
        ...states,
        update,
        referenceRef,
        contentRef
      };
    };
    var arrowMiddleware = ({
      arrowRef,
      padding
    }) => {
      return {
        name: "arrow",
        options: {
          element: arrowRef,
          padding
        },
        fn(args) {
          const arrowEl = vue.unref(arrowRef);
          if (!arrowEl)
            return {};
          return dom.arrow({
            element: arrowEl,
            padding
          }).fn(args);
        }
      };
    };
    exports.arrowMiddleware = arrowMiddleware;
    exports.getPositionDataWithUnit = getPositionDataWithUnit;
    exports.useFloating = useFloating;
    exports.useFloatingProps = useFloatingProps;
  }
});

// node_modules/element-plus/lib/hooks/use-cursor/index.js
var require_use_cursor = __commonJS({
  "node_modules/element-plus/lib/hooks/use-cursor/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var vue = require_vue();
    function useCursor(input) {
      const selectionRef = vue.ref();
      function recordCursor() {
        if (input.value == void 0)
          return;
        const { selectionStart, selectionEnd, value } = input.value;
        if (selectionStart == null || selectionEnd == null)
          return;
        const beforeTxt = value.slice(0, Math.max(0, selectionStart));
        const afterTxt = value.slice(Math.max(0, selectionEnd));
        selectionRef.value = {
          selectionStart,
          selectionEnd,
          value,
          beforeTxt,
          afterTxt
        };
      }
      function setCursor() {
        if (input.value == void 0 || selectionRef.value == void 0)
          return;
        const { value } = input.value;
        const { beforeTxt, afterTxt, selectionStart } = selectionRef.value;
        if (beforeTxt == void 0 || afterTxt == void 0 || selectionStart == void 0)
          return;
        let startPos = value.length;
        if (value.endsWith(afterTxt)) {
          startPos = value.length - afterTxt.length;
        } else if (value.startsWith(beforeTxt)) {
          startPos = beforeTxt.length;
        } else {
          const beforeLastChar = beforeTxt[selectionStart - 1];
          const newIndex = value.indexOf(beforeLastChar, selectionStart - 1);
          if (newIndex !== -1) {
            startPos = newIndex + 1;
          }
        }
        input.value.setSelectionRange(startPos, startPos);
      }
      return [recordCursor, setCursor];
    }
    exports.useCursor = useCursor;
  }
});

// node_modules/element-plus/lib/hooks/index.js
var require_hooks = __commonJS({
  "node_modules/element-plus/lib/hooks/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var index = require_use_attrs();
    var index$1 = require_use_common_props();
    var index$2 = require_use_deprecated();
    var index$3 = require_use_draggable();
    var index$4 = require_use_focus();
    var index$5 = require_use_form_item();
    var index$6 = require_use_global_config();
    var index$7 = require_use_locale();
    var index$8 = require_use_lockscreen();
    var index$9 = require_use_modal();
    var index$a = require_use_model_toggle();
    var index$b = require_use_prevent_global();
    var index$c = require_use_prop();
    var index$d = require_use_restore_active();
    var index$e = require_use_same_target();
    var index$f = require_use_teleport();
    var index$g = require_use_throttle_render();
    var index$h = require_use_timeout();
    var index$i = require_use_transition_fallthrough();
    var index$j = require_use_id();
    var index$k = require_use_escape_keydown();
    var index$l = require_use_popper_container();
    var index$m = require_use_intermediate_render();
    var index$n = require_use_delayed_toggle();
    var index$o = require_use_forward_ref();
    var index$p = require_use_namespace();
    var index$q = require_use_z_index();
    var index$r = require_use_floating();
    var index$s = require_use_cursor();
    exports.useAttrs = index.useAttrs;
    exports.useDisabled = index$1.useDisabled;
    exports.useSize = index$1.useSize;
    exports.useSizeProp = index$1.useSizeProp;
    exports.useDeprecated = index$2.useDeprecated;
    exports.useDraggable = index$3.useDraggable;
    exports.useFocus = index$4.useFocus;
    exports.useFormItem = index$5.useFormItem;
    exports.useFormItemInputId = index$5.useFormItemInputId;
    exports.provideGlobalConfig = index$6.provideGlobalConfig;
    exports.useGlobalConfig = index$6.useGlobalConfig;
    exports.buildLocaleContext = index$7.buildLocaleContext;
    exports.buildTranslator = index$7.buildTranslator;
    exports.translate = index$7.translate;
    exports.useLocale = index$7.useLocale;
    exports.useLockscreen = index$8.useLockscreen;
    exports.useModal = index$9.useModal;
    exports.createModelToggleComposable = index$a.createModelToggleComposable;
    exports.useModelToggle = index$a.useModelToggle;
    exports.useModelToggleEmits = index$a.useModelToggleEmits;
    exports.useModelToggleProps = index$a.useModelToggleProps;
    exports.usePreventGlobal = index$b.usePreventGlobal;
    exports.useProp = index$c.useProp;
    exports.useRestoreActive = index$d.useRestoreActive;
    exports.useSameTarget = index$e.useSameTarget;
    exports.useTeleport = index$f.useTeleport;
    exports.useThrottleRender = index$g.useThrottleRender;
    exports.useTimeout = index$h.useTimeout;
    exports.useTransitionFallthrough = index$i.useTransitionFallthrough;
    exports.useTransitionFallthroughEmits = index$i.useTransitionFallthroughEmits;
    exports.ID_INJECTION_KEY = index$j.ID_INJECTION_KEY;
    exports.useId = index$j.useId;
    exports.useEscapeKeydown = index$k.useEscapeKeydown;
    exports.POPPER_CONTAINER_ID = index$l.POPPER_CONTAINER_ID;
    exports.POPPER_CONTAINER_SELECTOR = index$l.POPPER_CONTAINER_SELECTOR;
    exports.usePopperContainer = index$l.usePopperContainer;
    exports.useDelayedRender = index$m.useDelayedRender;
    exports.useDelayedToggle = index$n.useDelayedToggle;
    exports.useDelayedToggleProps = index$n.useDelayedToggleProps;
    exports.FORWARD_REF_INJECTION_KEY = index$o.FORWARD_REF_INJECTION_KEY;
    exports.useForwardRef = index$o.useForwardRef;
    exports.useForwardRefDirective = index$o.useForwardRefDirective;
    exports.defaultNamespace = index$p.defaultNamespace;
    exports.useNamespace = index$p.useNamespace;
    exports.useZIndex = index$q.useZIndex;
    exports.arrowMiddleware = index$r.arrowMiddleware;
    exports.getPositionDataWithUnit = index$r.getPositionDataWithUnit;
    exports.useFloating = index$r.useFloating;
    exports.useFloatingProps = index$r.useFloatingProps;
    exports.useCursor = index$s.useCursor;
  }
});

// dep:element-plus_lib_hooks_index
var element_plus_lib_hooks_index_default = require_hooks();
export {
  element_plus_lib_hooks_index_default as default
};
//# sourceMappingURL=element-plus_lib_hooks_index.js.map
