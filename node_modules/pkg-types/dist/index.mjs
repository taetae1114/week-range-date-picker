import { statSync, promises } from 'fs';
import { resolve as resolve$1, dirname } from 'path';
import { resolvePath } from 'mlly';
import { resolve, join, isAbsolute } from 'pathe';

const defaultFindOptions = {
  startingFrom: ".",
  rootPattern: /^node_modules$/,
  reverse: false,
  test: (filePath) => {
    try {
      if (statSync(filePath).isFile()) {
        return true;
      }
    } catch {
    }
    return null;
  }
};
async function findFile(filename, _options = {}) {
  const options = { ...defaultFindOptions, ..._options };
  const basePath = resolve(options.startingFrom);
  const leadingSlash = basePath[0] === "/";
  const segments = basePath.split("/").filter(Boolean);
  if (leadingSlash) {
    segments[0] = "/" + segments[0];
  }
  let root = segments.findIndex((r) => r.match(options.rootPattern));
  if (root === -1) {
    root = 0;
  }
  if (!options.reverse) {
    for (let i = segments.length; i > root; i--) {
      const filePath = join(...segments.slice(0, i), filename);
      if (await options.test(filePath)) {
        return filePath;
      }
    }
  } else {
    for (let i = root + 1; i <= segments.length; i++) {
      const filePath = join(...segments.slice(0, i), filename);
      if (await options.test(filePath)) {
        return filePath;
      }
    }
  }
  throw new Error(`Cannot find matching ${filename} in ${options.startingFrom} or parent directories`);
}
function findNearestFile(filename, _options = {}) {
  return findFile(filename, _options);
}
function findFarthestFile(filename, _options = {}) {
  return findFile(filename, { ..._options, reverse: true });
}

function definePackageJSON(pkg) {
  return pkg;
}
function defineTSConfig(tsconfig) {
  return tsconfig;
}
async function readPackageJSON(id, opts = {}) {
  const resolvedPath = await resolvePackageJSON(id, opts);
  const blob = await promises.readFile(resolvedPath, "utf-8");
  return JSON.parse(blob);
}
async function writePackageJSON(path, pkg) {
  await promises.writeFile(path, JSON.stringify(pkg, null, 2));
}
async function readTSConfig(id, opts = {}) {
  const resolvedPath = await resolveTSConfig(id, opts);
  const blob = await promises.readFile(resolvedPath, "utf-8");
  const jsonc = await import('jsonc-parser');
  return jsonc.parse(blob);
}
async function writeTSConfig(path, tsconfig) {
  await promises.writeFile(path, JSON.stringify(tsconfig, null, 2));
}
async function resolvePackageJSON(id = process.cwd(), opts = {}) {
  const resolvedPath = isAbsolute(id) ? id : await resolvePath(id, opts);
  return findNearestFile("package.json", { startingFrom: resolvedPath, ...opts });
}
async function resolveTSConfig(id = process.cwd(), opts = {}) {
  const resolvedPath = isAbsolute(id) ? id : await resolvePath(id, opts);
  return findNearestFile("tsconfig.json", { startingFrom: resolvedPath, ...opts });
}
const lockFiles = ["yarn.lock", "package-lock.json", "pnpm-lock.yaml", "npm-shrinkwrap.json"];
async function resolveLockfile(id = process.cwd(), opts = {}) {
  const resolvedPath = isAbsolute(id) ? id : await resolvePath(id, opts);
  const _opts = { startingFrom: resolvedPath, ...opts };
  for (const lockFile of lockFiles) {
    try {
      return await findNearestFile(lockFile, _opts);
    } catch {
    }
  }
  throw new Error("No lockfile found from " + id);
}
async function findWorkspaceDir(id = process.cwd(), opts = {}) {
  const resolvedPath = isAbsolute(id) ? id : await resolvePath(id, opts);
  const _opts = { startingFrom: resolvedPath, ...opts };
  try {
    const r = await findNearestFile(".git/config", _opts);
    return resolve$1(r, "../..");
  } catch {
  }
  try {
    const r = await resolveLockfile(resolvedPath, { ..._opts, reverse: true });
    return dirname(r);
  } catch {
  }
  try {
    const r = await findFile(resolvedPath, _opts);
    return dirname(r);
  } catch {
  }
  throw new Error("Cannot detect workspace root from " + id);
}

export { definePackageJSON, defineTSConfig, findFarthestFile, findFile, findNearestFile, findWorkspaceDir, readPackageJSON, readTSConfig, resolveLockfile, resolvePackageJSON, resolveTSConfig, writePackageJSON, writeTSConfig };
